{"ast":null,"code":"/*! @azure/msal-common v9.1.1 2023-01-19 */\n'use strict';\n\nimport { __assign } from '../../_virtual/_tslib.js';\nimport { PerformanceEventStatus } from './PerformanceEvent.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nvar PerformanceClient = /** @class */function () {\n  /**\r\n   * Creates an instance of PerformanceClient,\r\n   * an abstract class containing core performance telemetry logic.\r\n   *\r\n   * @constructor\r\n   * @param {string} clientId Client ID of the application\r\n   * @param {string} authority Authority used by the application\r\n   * @param {Logger} logger Logger used by the application\r\n   * @param {string} libraryName Name of the library\r\n   * @param {string} libraryVersion Version of the library\r\n   */\n  function PerformanceClient(clientId, authority, logger, libraryName, libraryVersion, applicationTelemetry) {\n    this.authority = authority;\n    this.libraryName = libraryName;\n    this.libraryVersion = libraryVersion;\n    this.applicationTelemetry = applicationTelemetry;\n    this.clientId = clientId;\n    this.logger = logger;\n    this.callbacks = new Map();\n    this.eventsByCorrelationId = new Map();\n    this.staticFieldsByCorrelationId = new Map();\n    this.measurementsById = new Map();\n    this.countersByCorrelationId = new Map();\n  }\n  /**\r\n   * Starts and returns an platform-specific implementation of IPerformanceMeasurement.\r\n   * Note: this function can be changed to abstract at the next major version bump.\r\n   *\r\n   * @param {string} measureName\r\n   * @param {string} correlationId\r\n   * @returns {IPerformanceMeasurement}\r\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n  PerformanceClient.prototype.startPerformanceMeasurement = function (measureName, correlationId) {\n    return {};\n  };\n  /**\r\n   * Starts and returns an platform-specific implementation of IPerformanceMeasurement.\r\n   * Note: this incorrectly-named function will be removed at the next major version bump.\r\n   *\r\n   * @param {string} measureName\r\n   * @param {string} correlationId\r\n   * @returns {IPerformanceMeasurement}\r\n   */\n  /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\n  PerformanceClient.prototype.startPerformanceMeasuremeant = function (measureName, correlationId) {\n    return {};\n  };\n  /**\r\n   * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\r\n   *\r\n   * @param {PerformanceEvents} measureName\r\n   * @param {?string} [correlationId]\r\n   * @returns {InProgressPerformanceEvent}\r\n   */\n  PerformanceClient.prototype.startMeasurement = function (measureName, correlationId) {\n    var _this = this;\n    var _a, _b;\n    // Generate a placeholder correlation if the request does not provide one\n    var eventCorrelationId = correlationId || this.generateId();\n    if (!correlationId) {\n      this.logger.info(\"PerformanceClient: No correlation id provided for \" + measureName + \", generating\", eventCorrelationId);\n    }\n    // Duplicate code to address spelling error will be removed at the next major version bump.\n    this.logger.trace(\"PerformanceClient: Performance measurement started for \" + measureName, eventCorrelationId);\n    var validMeasurement;\n    var performanceMeasuremeant = this.startPerformanceMeasuremeant(measureName, eventCorrelationId);\n    if (performanceMeasuremeant.startMeasurement) {\n      performanceMeasuremeant.startMeasurement();\n      validMeasurement = performanceMeasuremeant;\n    } else {\n      var performanceMeasurement = this.startPerformanceMeasurement(measureName, eventCorrelationId);\n      performanceMeasurement.startMeasurement();\n      validMeasurement = performanceMeasurement;\n    }\n    var inProgressEvent = {\n      eventId: this.generateId(),\n      status: PerformanceEventStatus.InProgress,\n      authority: this.authority,\n      libraryName: this.libraryName,\n      libraryVersion: this.libraryVersion,\n      clientId: this.clientId,\n      name: measureName,\n      startTimeMs: Date.now(),\n      correlationId: eventCorrelationId\n    };\n    // Store in progress events so they can be discarded if not ended properly\n    this.cacheEventByCorrelationId(inProgressEvent);\n    var staticFields = {\n      appName: (_a = this.applicationTelemetry) === null || _a === void 0 ? void 0 : _a.appName,\n      appVersion: (_b = this.applicationTelemetry) === null || _b === void 0 ? void 0 : _b.appVersion\n    };\n    this.addStaticFields(staticFields, eventCorrelationId);\n    this.cacheMeasurement(inProgressEvent, validMeasurement);\n    // Return the event and functions the caller can use to properly end/flush the measurement\n    return {\n      endMeasurement: function (event) {\n        var completedEvent = _this.endMeasurement(__assign(__assign({}, inProgressEvent), event));\n        if (completedEvent) {\n          // Cache event so that submeasurements can be added downstream\n          _this.cacheEventByCorrelationId(completedEvent);\n        }\n        return completedEvent;\n      },\n      flushMeasurement: function () {\n        return _this.flushMeasurements(inProgressEvent.name, inProgressEvent.correlationId);\n      },\n      discardMeasurement: function () {\n        return _this.discardMeasurements(inProgressEvent.correlationId);\n      },\n      addStaticFields: function (fields) {\n        return _this.addStaticFields(fields, inProgressEvent.correlationId);\n      },\n      increment: function (counters) {\n        return _this.increment(counters, inProgressEvent.correlationId);\n      },\n      measurement: validMeasurement,\n      event: inProgressEvent\n    };\n  };\n  /**\r\n   * Stops measuring the performance for an operation. Should only be called directly by PerformanceClient classes,\r\n   * as consumers should instead use the function returned by startMeasurement.\r\n   *\r\n   * @param {PerformanceEvent} event\r\n   * @returns {(PerformanceEvent | null)}\r\n   */\n  PerformanceClient.prototype.endMeasurement = function (event) {\n    var performanceMeasurement = this.measurementsById.get(event.eventId);\n    if (performanceMeasurement) {\n      // Immediately delete so that the same event isnt ended twice\n      this.measurementsById.delete(event.eventId);\n      performanceMeasurement.endMeasurement();\n      var durationMs = performanceMeasurement.flushMeasurement();\n      // null indicates no measurement was taken (e.g. needed performance APIs not present)\n      if (durationMs !== null) {\n        this.logger.trace(\"PerformanceClient: Performance measurement ended for \" + event.name + \": \" + durationMs + \" ms\", event.correlationId);\n        var completedEvent = __assign(__assign({\n          // Allow duration to be overwritten when event ends (e.g. testing), but not status\n          durationMs: Math.round(durationMs)\n        }, event), {\n          status: PerformanceEventStatus.Completed\n        });\n        return completedEvent;\n      } else {\n        this.logger.trace(\"PerformanceClient: Performance measurement not taken\", event.correlationId);\n      }\n    } else {\n      this.logger.trace(\"PerformanceClient: Measurement not found for \" + event.eventId, event.correlationId);\n    }\n    return null;\n  };\n  /**\r\n   * Saves extra information to be emitted when the measurements are flushed\r\n   * @param fields\r\n   * @param correlationId\r\n   */\n  PerformanceClient.prototype.addStaticFields = function (fields, correlationId) {\n    var existingStaticFields = this.staticFieldsByCorrelationId.get(correlationId);\n    if (existingStaticFields) {\n      this.logger.trace(\"PerformanceClient: Updating static fields\");\n      this.staticFieldsByCorrelationId.set(correlationId, __assign(__assign({}, existingStaticFields), fields));\n    } else {\n      this.logger.trace(\"PerformanceClient: Adding static fields\");\n      this.staticFieldsByCorrelationId.set(correlationId, fields);\n    }\n  };\n  /**\r\n   * Increment counters to be emitted when the measurements are flushed\r\n   * @param counters {Counters}\r\n   * @param correlationId {string} correlation identifier\r\n   */\n  PerformanceClient.prototype.increment = function (counters, correlationId) {\n    var existing = this.countersByCorrelationId.get(correlationId);\n    if (!existing) {\n      this.logger.trace(\"PerformanceClient: Setting counters\");\n      this.countersByCorrelationId.set(correlationId, __assign({}, counters));\n      return;\n    }\n    this.logger.trace(\"PerformanceClient: Updating counters\");\n    for (var counter in counters) {\n      if (!existing.hasOwnProperty(counter)) {\n        existing[counter] = 0;\n      }\n      existing[counter] += counters[counter];\n    }\n  };\n  /**\r\n   * Upserts event into event cache.\r\n   * First key is the correlation id, second key is the event id.\r\n   * Allows for events to be grouped by correlation id,\r\n   * and to easily allow for properties on them to be updated.\r\n   *\r\n   * @private\r\n   * @param {PerformanceEvent} event\r\n   */\n  PerformanceClient.prototype.cacheEventByCorrelationId = function (event) {\n    var existingEvents = this.eventsByCorrelationId.get(event.correlationId);\n    if (existingEvents) {\n      this.logger.trace(\"PerformanceClient: Performance measurement for \" + event.name + \" added/updated\", event.correlationId);\n      existingEvents.set(event.eventId, event);\n    } else {\n      this.logger.trace(\"PerformanceClient: Performance measurement for \" + event.name + \" started\", event.correlationId);\n      this.eventsByCorrelationId.set(event.correlationId, new Map().set(event.eventId, event));\n    }\n  };\n  /**\r\n   * Cache measurements by their id.\r\n   *\r\n   * @private\r\n   * @param {PerformanceEvent} event\r\n   * @param {IPerformanceMeasurement} measurement\r\n   */\n  PerformanceClient.prototype.cacheMeasurement = function (event, measurement) {\n    this.measurementsById.set(event.eventId, measurement);\n  };\n  /**\r\n   * Gathers and emits performance events for measurements taked for the given top-level API and correlation ID.\r\n   *\r\n   * @param {PerformanceEvents} measureName\r\n   * @param {string} correlationId\r\n   */\n  PerformanceClient.prototype.flushMeasurements = function (measureName, correlationId) {\n    var _this = this;\n    this.logger.trace(\"PerformanceClient: Performance measurements flushed for \" + measureName, correlationId);\n    var eventsForCorrelationId = this.eventsByCorrelationId.get(correlationId);\n    var staticFields = this.staticFieldsByCorrelationId.get(correlationId);\n    var counters = this.countersByCorrelationId.get(correlationId);\n    if (eventsForCorrelationId) {\n      this.discardCache(correlationId);\n      /*\r\n       * Manually end incomplete submeasurements to ensure there arent orphaned/never ending events.\r\n       * Incomplete submeasurements are likely an instrumentation bug that should be fixed.\r\n       * IE only supports Map.forEach.\r\n       */\n      var completedEvents_1 = [];\n      eventsForCorrelationId.forEach(function (event) {\n        if (event.name !== measureName && event.status !== PerformanceEventStatus.Completed) {\n          _this.logger.trace(\"PerformanceClient: Incomplete submeasurement \" + event.name + \" found for \" + measureName, correlationId);\n          var completedEvent = _this.endMeasurement(event);\n          if (completedEvent) {\n            completedEvents_1.push(completedEvent);\n          }\n        }\n        completedEvents_1.push(event);\n      });\n      // Sort events by start time (earliest first)\n      var sortedCompletedEvents = completedEvents_1.sort(function (eventA, eventB) {\n        return eventA.startTimeMs - eventB.startTimeMs;\n      });\n      // Take completed top level event and add completed submeasurements durations as properties\n      var topLevelEvents = sortedCompletedEvents.filter(function (event) {\n        return event.name === measureName && event.status === PerformanceEventStatus.Completed;\n      });\n      if (topLevelEvents.length > 0) {\n        /*\r\n         * Only take the first top-level event if there are multiple events with the same correlation id.\r\n         * This greatly simplifies logic for submeasurements.\r\n         */\n        if (topLevelEvents.length > 1) {\n          this.logger.verbose(\"PerformanceClient: Multiple distinct top-level performance events found, using the first\", correlationId);\n        }\n        var topLevelEvent = topLevelEvents[0];\n        this.logger.verbose(\"PerformanceClient: Measurement found for \" + measureName, correlationId);\n        // Build event object with top level and sub measurements\n        var eventToEmit = sortedCompletedEvents.reduce(function (previous, current) {\n          if (current.name !== measureName) {\n            _this.logger.trace(\"PerformanceClient: Complete submeasurement found for \" + current.name, correlationId);\n            // TODO: Emit additional properties for each subMeasurement\n            var subMeasurementName = current.name + \"DurationMs\";\n            /*\r\n             * Some code paths, such as resolving an authority, can occur multiple times.\r\n             * Only take the first measurement, since the second could be read from the cache,\r\n             * or due to the same correlation id being used for two distinct requests.\r\n             */\n            if (!previous[subMeasurementName]) {\n              previous[subMeasurementName] = current.durationMs;\n            } else {\n              _this.logger.verbose(\"PerformanceClient: Submeasurement for \" + measureName + \" already exists for \" + current.name + \", ignoring\", correlationId);\n            }\n          }\n          return previous;\n        }, topLevelEvent);\n        var finalEvent = __assign(__assign(__assign({}, eventToEmit), staticFields), counters);\n        this.emitEvents([finalEvent], eventToEmit.correlationId);\n      } else {\n        this.logger.verbose(\"PerformanceClient: No completed top-level measurements found for \" + measureName, correlationId);\n      }\n    } else {\n      this.logger.verbose(\"PerformanceClient: No measurements found\", correlationId);\n    }\n  };\n  /**\r\n   * Removes measurements for a given correlation id.\r\n   *\r\n   * @param {string} correlationId\r\n   */\n  PerformanceClient.prototype.discardMeasurements = function (correlationId) {\n    this.logger.trace(\"PerformanceClient: Performance measurements discarded\", correlationId);\n    this.eventsByCorrelationId.delete(correlationId);\n  };\n  /**\r\n   * Removes cache for a given correlation id.\r\n   *\r\n   * @param {string} correlation identifier\r\n   */\n  PerformanceClient.prototype.discardCache = function (correlationId) {\n    this.discardMeasurements(correlationId);\n    this.logger.trace(\"PerformanceClient: Static fields discarded\", correlationId);\n    this.staticFieldsByCorrelationId.delete(correlationId);\n    this.logger.trace(\"PerformanceClient: Counters discarded\", correlationId);\n    this.countersByCorrelationId.delete(correlationId);\n  };\n  /**\r\n   * Registers a callback function to receive performance events.\r\n   *\r\n   * @param {PerformanceCallbackFunction} callback\r\n   * @returns {string}\r\n   */\n  PerformanceClient.prototype.addPerformanceCallback = function (callback) {\n    var callbackId = this.generateId();\n    this.callbacks.set(callbackId, callback);\n    this.logger.verbose(\"PerformanceClient: Performance callback registered with id: \" + callbackId);\n    return callbackId;\n  };\n  /**\r\n   * Removes a callback registered with addPerformanceCallback.\r\n   *\r\n   * @param {string} callbackId\r\n   * @returns {boolean}\r\n   */\n  PerformanceClient.prototype.removePerformanceCallback = function (callbackId) {\n    var result = this.callbacks.delete(callbackId);\n    if (result) {\n      this.logger.verbose(\"PerformanceClient: Performance callback \" + callbackId + \" removed.\");\n    } else {\n      this.logger.verbose(\"PerformanceClient: Performance callback \" + callbackId + \" not removed.\");\n    }\n    return result;\n  };\n  /**\r\n   * Emits events to all registered callbacks.\r\n   *\r\n   * @param {PerformanceEvent[]} events\r\n   * @param {?string} [correlationId]\r\n   */\n  PerformanceClient.prototype.emitEvents = function (events, correlationId) {\n    var _this = this;\n    this.logger.verbose(\"PerformanceClient: Emitting performance events\", correlationId);\n    this.callbacks.forEach(function (callback, callbackId) {\n      _this.logger.trace(\"PerformanceClient: Emitting event to callback \" + callbackId, correlationId);\n      callback.apply(null, [events]);\n    });\n  };\n  return PerformanceClient;\n}();\nexport { PerformanceClient };","map":{"version":3,"mappings":"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","names":["PerformanceClient","authority","logger","libraryName","libraryVersion","applicationTelemetry","clientId","callbacks","Map","eventsByCorrelationId","staticFieldsByCorrelationId","measurementsById","countersByCorrelationId","measureName","correlationId","_this","eventCorrelationId","generateId","info","trace","validMeasurement","performanceMeasuremeant","startPerformanceMeasuremeant","startMeasurement","performanceMeasurement","startPerformanceMeasurement","inProgressEvent","eventId","status","PerformanceEventStatus","InProgress","name","startTimeMs","Date","now","cacheEventByCorrelationId","staticFields","appName","appVersion","addStaticFields","cacheMeasurement","endMeasurement","event","completedEvent","flushMeasurement","flushMeasurements","discardMeasurement","discardMeasurements","fields","increment","counters","measurement","get","delete","durationMs","Math","round","Completed","existingStaticFields","set","existing","counter","hasOwnProperty","existingEvents","eventsForCorrelationId","discardCache","completedEvents_1","forEach","push","sortedCompletedEvents","sort","eventA","eventB","topLevelEvents","filter","length","verbose","topLevelEvent","eventToEmit","reduce","previous","current","subMeasurementName","finalEvent","emitEvents","callback","callbackId","result","events","apply"],"sources":["/home/user/mischangas/node_modules/@azure/msal-common/src/telemetry/performance/PerformanceClient.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { ApplicationTelemetry } from \"../../config/ClientConfiguration\";\r\nimport { Logger } from \"../../logger/Logger\";\r\nimport { InProgressPerformanceEvent, IPerformanceClient, PerformanceCallbackFunction } from \"./IPerformanceClient\";\r\nimport { IPerformanceMeasurement } from \"./IPerformanceMeasurement\";\r\nimport { Counters, PerformanceEvent, PerformanceEvents, PerformanceEventStatus, StaticFields } from \"./PerformanceEvent\";\r\n\r\nexport abstract class PerformanceClient implements IPerformanceClient {\r\n    protected authority: string;\r\n    protected libraryName: string;\r\n    protected libraryVersion: string;\r\n    protected applicationTelemetry: ApplicationTelemetry;\r\n    protected clientId: string;\r\n    protected logger: Logger;\r\n    protected callbacks: Map<string, PerformanceCallbackFunction>;\r\n\r\n    /**\r\n     * Multiple events with the same correlation id.\r\n     * Double keyed by correlation id and event id.\r\n     * @protected\r\n     * @type {Map<string, Map<string, PerformanceEvent>>}\r\n     */\r\n    protected eventsByCorrelationId: Map<string, Map<string, PerformanceEvent>>;\r\n\r\n    /**\r\n     * Fields to be emitted which are scoped to the top level request and whose value will not change in submeasurements\r\n     * For example: App name, version, etc.\r\n     */\r\n    protected staticFieldsByCorrelationId: Map<string, StaticFields>;\r\n\r\n    /**\r\n     * Counters to be emitted which are scoped to the top level request and whose value may change in sub-measurements\r\n     */\r\n    protected countersByCorrelationId: Map<string, Counters>;\r\n\r\n    /**\r\n     * Underlying performance measurements for each operation\r\n     *\r\n     * @protected\r\n     * @type {Map<string, IPerformanceMeasurement>}\r\n     */\r\n    protected measurementsById: Map<string, IPerformanceMeasurement>;\r\n\r\n    /**\r\n     * Creates an instance of PerformanceClient,\r\n     * an abstract class containing core performance telemetry logic.\r\n     *\r\n     * @constructor\r\n     * @param {string} clientId Client ID of the application\r\n     * @param {string} authority Authority used by the application\r\n     * @param {Logger} logger Logger used by the application\r\n     * @param {string} libraryName Name of the library\r\n     * @param {string} libraryVersion Version of the library\r\n     */\r\n    constructor(clientId: string, authority: string, logger: Logger, libraryName: string, libraryVersion: string, applicationTelemetry: ApplicationTelemetry) {\r\n        this.authority = authority;\r\n        this.libraryName = libraryName;\r\n        this.libraryVersion = libraryVersion;\r\n        this.applicationTelemetry = applicationTelemetry;\r\n        this.clientId = clientId;\r\n        this.logger = logger;\r\n        this.callbacks = new Map();\r\n        this.eventsByCorrelationId = new Map();\r\n        this.staticFieldsByCorrelationId = new Map();\r\n        this.measurementsById = new Map();\r\n        this.countersByCorrelationId = new Map();\r\n    }\r\n\r\n    /**\r\n     * Generates and returns a unique id, typically a guid.\r\n     *\r\n     * @abstract\r\n     * @returns {string}\r\n     */\r\n    abstract generateId(): string;\r\n\r\n    /**\r\n     * Starts and returns an platform-specific implementation of IPerformanceMeasurement.\r\n     * Note: this function can be changed to abstract at the next major version bump.\r\n     *\r\n     * @param {string} measureName\r\n     * @param {string} correlationId\r\n     * @returns {IPerformanceMeasurement}\r\n     */\r\n    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\r\n    startPerformanceMeasurement(measureName: string, correlationId: string): IPerformanceMeasurement {\r\n        return {} as IPerformanceMeasurement;\r\n    }\r\n\r\n    /**\r\n     * Starts and returns an platform-specific implementation of IPerformanceMeasurement.\r\n     * Note: this incorrectly-named function will be removed at the next major version bump.\r\n     *\r\n     * @param {string} measureName\r\n     * @param {string} correlationId\r\n     * @returns {IPerformanceMeasurement}\r\n     */\r\n    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */\r\n    startPerformanceMeasuremeant(measureName: string, correlationId: string): IPerformanceMeasurement {\r\n        return {} as IPerformanceMeasurement;\r\n    }\r\n\r\n    /**\r\n     * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\r\n     *\r\n     * @param {PerformanceEvents} measureName\r\n     * @param {?string} [correlationId]\r\n     * @returns {InProgressPerformanceEvent}\r\n     */\r\n    startMeasurement(measureName: PerformanceEvents, correlationId?: string): InProgressPerformanceEvent {\r\n        // Generate a placeholder correlation if the request does not provide one\r\n        const eventCorrelationId = correlationId || this.generateId();\r\n        if (!correlationId) {\r\n            this.logger.info(`PerformanceClient: No correlation id provided for ${measureName}, generating`, eventCorrelationId);\r\n        }\r\n\r\n        // Duplicate code to address spelling error will be removed at the next major version bump.\r\n        this.logger.trace(`PerformanceClient: Performance measurement started for ${measureName}`, eventCorrelationId);\r\n        let validMeasurement: IPerformanceMeasurement;\r\n        const performanceMeasuremeant = this.startPerformanceMeasuremeant(measureName, eventCorrelationId);\r\n        if (performanceMeasuremeant.startMeasurement) {\r\n            performanceMeasuremeant.startMeasurement();\r\n            validMeasurement = performanceMeasuremeant;\r\n        } else {\r\n            const performanceMeasurement = this.startPerformanceMeasurement(measureName, eventCorrelationId);\r\n            performanceMeasurement.startMeasurement();\r\n            validMeasurement = performanceMeasurement;\r\n        }\r\n\r\n        const inProgressEvent: PerformanceEvent = {\r\n            eventId: this.generateId(),\r\n            status: PerformanceEventStatus.InProgress,\r\n            authority: this.authority,\r\n            libraryName: this.libraryName,\r\n            libraryVersion: this.libraryVersion,\r\n            clientId: this.clientId,\r\n            name: measureName,\r\n            startTimeMs: Date.now(),\r\n            correlationId: eventCorrelationId,\r\n        };\r\n\r\n        // Store in progress events so they can be discarded if not ended properly\r\n        this.cacheEventByCorrelationId(inProgressEvent);\r\n\r\n        const staticFields: StaticFields = {\r\n            appName: this.applicationTelemetry?.appName,\r\n            appVersion: this.applicationTelemetry?.appVersion,\r\n        };\r\n        this.addStaticFields(staticFields, eventCorrelationId);\r\n        this.cacheMeasurement(inProgressEvent, validMeasurement);\r\n\r\n        // Return the event and functions the caller can use to properly end/flush the measurement\r\n        return {\r\n            endMeasurement: (event?: Partial<PerformanceEvent>): PerformanceEvent | null => {\r\n                const completedEvent = this.endMeasurement({\r\n                    // Initial set of event properties\r\n                    ...inProgressEvent,\r\n                    // Properties set when event ends\r\n                    ...event\r\n                });\r\n\r\n                if (completedEvent) {\r\n                    // Cache event so that submeasurements can be added downstream\r\n                    this.cacheEventByCorrelationId(completedEvent);\r\n                }\r\n                return completedEvent;\r\n            },\r\n            flushMeasurement: () => {\r\n                return this.flushMeasurements(inProgressEvent.name, inProgressEvent.correlationId);\r\n            },\r\n            discardMeasurement: () => {\r\n                return this.discardMeasurements(inProgressEvent.correlationId);\r\n            },\r\n            addStaticFields: (fields: StaticFields) => {\r\n                return this.addStaticFields(fields, inProgressEvent.correlationId);\r\n            },\r\n            increment: (counters: Counters) => {\r\n                return this.increment(counters, inProgressEvent.correlationId);\r\n            },\r\n            measurement: validMeasurement,\r\n            event: inProgressEvent\r\n        };\r\n\r\n    }\r\n\r\n    /**\r\n     * Stops measuring the performance for an operation. Should only be called directly by PerformanceClient classes,\r\n     * as consumers should instead use the function returned by startMeasurement.\r\n     *\r\n     * @param {PerformanceEvent} event\r\n     * @returns {(PerformanceEvent | null)}\r\n     */\r\n    endMeasurement(event: PerformanceEvent): PerformanceEvent | null {\r\n        const performanceMeasurement = this.measurementsById.get(event.eventId);\r\n        if (performanceMeasurement) {\r\n            // Immediately delete so that the same event isnt ended twice\r\n            this.measurementsById.delete(event.eventId);\r\n            performanceMeasurement.endMeasurement();\r\n            const durationMs = performanceMeasurement.flushMeasurement();\r\n            // null indicates no measurement was taken (e.g. needed performance APIs not present)\r\n            if (durationMs !== null) {\r\n                this.logger.trace(`PerformanceClient: Performance measurement ended for ${event.name}: ${durationMs} ms`, event.correlationId);\r\n                const completedEvent: PerformanceEvent = {\r\n                    // Allow duration to be overwritten when event ends (e.g. testing), but not status\r\n                    durationMs: Math.round(durationMs),\r\n                    ...event,\r\n                    status: PerformanceEventStatus.Completed,\r\n                };\r\n\r\n                return completedEvent;\r\n            } else {\r\n                this.logger.trace(\"PerformanceClient: Performance measurement not taken\", event.correlationId);\r\n            }\r\n        } else {\r\n            this.logger.trace(`PerformanceClient: Measurement not found for ${event.eventId}`, event.correlationId);\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Saves extra information to be emitted when the measurements are flushed\r\n     * @param fields\r\n     * @param correlationId\r\n     */\r\n    addStaticFields(fields: StaticFields, correlationId: string) : void{\r\n        const existingStaticFields = this.staticFieldsByCorrelationId.get(correlationId);\r\n        if (existingStaticFields) {\r\n            this.logger.trace(\"PerformanceClient: Updating static fields\");\r\n            this.staticFieldsByCorrelationId.set(correlationId, {...existingStaticFields, ...fields});\r\n        } else {\r\n            this.logger.trace(\"PerformanceClient: Adding static fields\");\r\n            this.staticFieldsByCorrelationId.set(correlationId, fields);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Increment counters to be emitted when the measurements are flushed\r\n     * @param counters {Counters}\r\n     * @param correlationId {string} correlation identifier\r\n     */\r\n    increment(counters: Counters, correlationId: string): void {\r\n        const existing: Counters | undefined = this.countersByCorrelationId.get(correlationId);\r\n        if (!existing) {\r\n            this.logger.trace(\"PerformanceClient: Setting counters\");\r\n            this.countersByCorrelationId.set(correlationId, { ...counters });\r\n            return;\r\n        }\r\n\r\n        this.logger.trace(\"PerformanceClient: Updating counters\");\r\n        for (const counter in counters) {\r\n            if (!existing.hasOwnProperty(counter)) {\r\n                existing[counter] = 0;\r\n            }\r\n            existing[counter] += counters[counter];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Upserts event into event cache.\r\n     * First key is the correlation id, second key is the event id.\r\n     * Allows for events to be grouped by correlation id,\r\n     * and to easily allow for properties on them to be updated.\r\n     *\r\n     * @private\r\n     * @param {PerformanceEvent} event\r\n     */\r\n    private cacheEventByCorrelationId(event: PerformanceEvent) {\r\n        const existingEvents = this.eventsByCorrelationId.get(event.correlationId);\r\n        if (existingEvents) {\r\n            this.logger.trace(`PerformanceClient: Performance measurement for ${event.name} added/updated`, event.correlationId);\r\n            existingEvents.set(event.eventId, event);\r\n        } else {\r\n            this.logger.trace(`PerformanceClient: Performance measurement for ${event.name} started`, event.correlationId);\r\n            this.eventsByCorrelationId.set(event.correlationId, new Map().set(event.eventId, event));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Cache measurements by their id.\r\n     *\r\n     * @private\r\n     * @param {PerformanceEvent} event\r\n     * @param {IPerformanceMeasurement} measurement\r\n     */\r\n    private cacheMeasurement(event: PerformanceEvent, measurement: IPerformanceMeasurement) {\r\n        this.measurementsById.set(event.eventId, measurement);\r\n    }\r\n\r\n    /**\r\n     * Gathers and emits performance events for measurements taked for the given top-level API and correlation ID.\r\n     *\r\n     * @param {PerformanceEvents} measureName\r\n     * @param {string} correlationId\r\n     */\r\n    flushMeasurements(measureName: PerformanceEvents, correlationId: string): void {\r\n        this.logger.trace(`PerformanceClient: Performance measurements flushed for ${measureName}`, correlationId);\r\n        const eventsForCorrelationId = this.eventsByCorrelationId.get(correlationId);\r\n        const staticFields = this.staticFieldsByCorrelationId.get(correlationId);\r\n        const counters = this.countersByCorrelationId.get(correlationId);\r\n\r\n        if (eventsForCorrelationId) {\r\n            this.discardCache(correlationId);\r\n\r\n            /*\r\n             * Manually end incomplete submeasurements to ensure there arent orphaned/never ending events.\r\n             * Incomplete submeasurements are likely an instrumentation bug that should be fixed.\r\n             * IE only supports Map.forEach.\r\n             */\r\n            const completedEvents: PerformanceEvent[] = [];\r\n            eventsForCorrelationId.forEach(event => {\r\n                if (event.name !== measureName && event.status !== PerformanceEventStatus.Completed) {\r\n                    this.logger.trace(`PerformanceClient: Incomplete submeasurement ${event.name} found for ${measureName}`, correlationId);\r\n\r\n                    const completedEvent = this.endMeasurement(event);\r\n                    if (completedEvent) {\r\n                        completedEvents.push(completedEvent);\r\n                    }\r\n                }\r\n\r\n                completedEvents.push(event);\r\n            });\r\n\r\n            // Sort events by start time (earliest first)\r\n            const sortedCompletedEvents = completedEvents.sort((eventA, eventB) => eventA.startTimeMs - eventB.startTimeMs);\r\n\r\n            // Take completed top level event and add completed submeasurements durations as properties\r\n            const topLevelEvents = sortedCompletedEvents.filter(event => event.name === measureName && event.status === PerformanceEventStatus.Completed);\r\n            if (topLevelEvents.length > 0) {\r\n                /*\r\n                 * Only take the first top-level event if there are multiple events with the same correlation id.\r\n                 * This greatly simplifies logic for submeasurements.\r\n                 */\r\n                if (topLevelEvents.length > 1) {\r\n                    this.logger.verbose(\"PerformanceClient: Multiple distinct top-level performance events found, using the first\", correlationId);\r\n                }\r\n                const topLevelEvent = topLevelEvents[0];\r\n                this.logger.verbose(`PerformanceClient: Measurement found for ${measureName}`, correlationId);\r\n\r\n                // Build event object with top level and sub measurements\r\n                const eventToEmit = sortedCompletedEvents.reduce((previous, current) => {\r\n                    if (current.name !== measureName) {\r\n                        this.logger.trace(`PerformanceClient: Complete submeasurement found for ${current.name}`, correlationId);\r\n                        // TODO: Emit additional properties for each subMeasurement\r\n                        const subMeasurementName = `${current.name}DurationMs`;\r\n                        /*\r\n                         * Some code paths, such as resolving an authority, can occur multiple times.\r\n                         * Only take the first measurement, since the second could be read from the cache,\r\n                         * or due to the same correlation id being used for two distinct requests.\r\n                         */\r\n                        if (!previous[subMeasurementName]) {\r\n                            previous[subMeasurementName] = current.durationMs;\r\n                        } else {\r\n                            this.logger.verbose(`PerformanceClient: Submeasurement for ${measureName} already exists for ${current.name}, ignoring`, correlationId);\r\n                        }\r\n                    }\r\n\r\n                    return previous;\r\n                }, topLevelEvent);\r\n\r\n                const finalEvent: PerformanceEvent = {\r\n                    ...eventToEmit,\r\n                    ...staticFields,\r\n                    ...counters\r\n                };\r\n\r\n                this.emitEvents([finalEvent], eventToEmit.correlationId);\r\n            } else {\r\n                this.logger.verbose(`PerformanceClient: No completed top-level measurements found for ${measureName}`, correlationId);\r\n            }\r\n        } else {\r\n            this.logger.verbose(\"PerformanceClient: No measurements found\", correlationId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes measurements for a given correlation id.\r\n     *\r\n     * @param {string} correlationId\r\n     */\r\n    discardMeasurements(correlationId: string): void {\r\n        this.logger.trace(\"PerformanceClient: Performance measurements discarded\", correlationId);\r\n        this.eventsByCorrelationId.delete(correlationId);\r\n    }\r\n\r\n    /**\r\n     * Removes cache for a given correlation id.\r\n     *\r\n     * @param {string} correlation identifier\r\n     */\r\n    private discardCache(correlationId: string): void {\r\n        this.discardMeasurements(correlationId);\r\n\r\n        this.logger.trace(\"PerformanceClient: Static fields discarded\", correlationId);\r\n        this.staticFieldsByCorrelationId.delete(correlationId);\r\n\r\n        this.logger.trace(\"PerformanceClient: Counters discarded\", correlationId);\r\n        this.countersByCorrelationId.delete(correlationId);\r\n    }\r\n\r\n    /**\r\n     * Registers a callback function to receive performance events.\r\n     *\r\n     * @param {PerformanceCallbackFunction} callback\r\n     * @returns {string}\r\n     */\r\n    addPerformanceCallback(callback: PerformanceCallbackFunction): string {\r\n        const callbackId = this.generateId();\r\n        this.callbacks.set(callbackId, callback);\r\n        this.logger.verbose(`PerformanceClient: Performance callback registered with id: ${callbackId}`);\r\n\r\n        return callbackId;\r\n    }\r\n\r\n    /**\r\n     * Removes a callback registered with addPerformanceCallback.\r\n     *\r\n     * @param {string} callbackId\r\n     * @returns {boolean}\r\n     */\r\n    removePerformanceCallback(callbackId: string): boolean {\r\n        const result = this.callbacks.delete(callbackId);\r\n\r\n        if (result) {\r\n            this.logger.verbose(`PerformanceClient: Performance callback ${callbackId} removed.`);\r\n        } else {\r\n            this.logger.verbose(`PerformanceClient: Performance callback ${callbackId} not removed.`);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Emits events to all registered callbacks.\r\n     *\r\n     * @param {PerformanceEvent[]} events\r\n     * @param {?string} [correlationId]\r\n     */\r\n    emitEvents(events: PerformanceEvent[], correlationId: string): void {\r\n        this.logger.verbose(\"PerformanceClient: Emitting performance events\", correlationId);\r\n\r\n        this.callbacks.forEach((callback: PerformanceCallbackFunction, callbackId: string) => {\r\n            this.logger.trace(`PerformanceClient: Emitting event to callback ${callbackId}`, correlationId);\r\n            callback.apply(null, [events]);\r\n        });\r\n    }\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}