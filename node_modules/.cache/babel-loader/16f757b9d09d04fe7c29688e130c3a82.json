{"ast":null,"code":"/*! @azure/msal-common v9.1.1 2023-01-19 */\n'use strict';\n\nimport { __awaiter, __generator, __extends } from '../_virtual/_tslib.js';\nimport { Constants, CredentialType, AuthenticationScheme, CacheSchemaType, THE_FAMILY_ID, APP_METADATA, AUTHORITY_METADATA_CONSTANTS } from '../utils/Constants.js';\nimport { CredentialEntity } from './entities/CredentialEntity.js';\nimport { ScopeSet } from '../request/ScopeSet.js';\nimport { AccountEntity } from './entities/AccountEntity.js';\nimport { AuthError } from '../error/AuthError.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { AuthToken } from '../account/AuthToken.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\r\n */\nvar CacheManager = /** @class */function () {\n  function CacheManager(clientId, cryptoImpl) {\n    this.clientId = clientId;\n    this.cryptoImpl = cryptoImpl;\n  }\n  /**\r\n   * Returns all accounts in cache\r\n   */\n  CacheManager.prototype.getAllAccounts = function () {\n    var _this = this;\n    var currentAccounts = this.getAccountsFilteredBy();\n    var accountValues = Object.keys(currentAccounts).map(function (accountKey) {\n      return currentAccounts[accountKey];\n    });\n    var numAccounts = accountValues.length;\n    if (numAccounts < 1) {\n      return [];\n    } else {\n      var allAccounts = accountValues.map(function (value) {\n        var accountEntity = CacheManager.toObject(new AccountEntity(), value);\n        var accountInfo = accountEntity.getAccountInfo();\n        var idToken = _this.readIdTokenFromCache(_this.clientId, accountInfo);\n        if (idToken && !accountInfo.idTokenClaims) {\n          accountInfo.idToken = idToken.secret;\n          accountInfo.idTokenClaims = new AuthToken(idToken.secret, _this.cryptoImpl).claims;\n        }\n        return accountInfo;\n      });\n      return allAccounts;\n    }\n  };\n  /**\r\n   * saves a cache record\r\n   * @param cacheRecord\r\n   */\n  CacheManager.prototype.saveCacheRecord = function (cacheRecord) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!cacheRecord) {\n              throw ClientAuthError.createNullOrUndefinedCacheRecord();\n            }\n            if (!!cacheRecord.account) {\n              this.setAccount(cacheRecord.account);\n            }\n            if (!!cacheRecord.idToken) {\n              this.setIdTokenCredential(cacheRecord.idToken);\n            }\n            if (!!!cacheRecord.accessToken) return [3 /*break*/, 2];\n            return [4 /*yield*/, this.saveAccessToken(cacheRecord.accessToken)];\n          case 1:\n            _a.sent();\n            _a.label = 2;\n          case 2:\n            if (!!cacheRecord.refreshToken) {\n              this.setRefreshTokenCredential(cacheRecord.refreshToken);\n            }\n            if (!!cacheRecord.appMetadata) {\n              this.setAppMetadata(cacheRecord.appMetadata);\n            }\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * saves access token credential\r\n   * @param credential\r\n   */\n  CacheManager.prototype.saveAccessToken = function (credential) {\n    return __awaiter(this, void 0, void 0, function () {\n      var currentTokenCache, currentScopes, currentAccessTokens, removedAccessTokens_1;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            currentTokenCache = this.getCredentialsFilteredBy({\n              clientId: credential.clientId,\n              credentialType: credential.credentialType,\n              environment: credential.environment,\n              homeAccountId: credential.homeAccountId,\n              realm: credential.realm,\n              tokenType: credential.tokenType,\n              requestedClaimsHash: credential.requestedClaimsHash\n            });\n            currentScopes = ScopeSet.fromString(credential.target);\n            currentAccessTokens = Object.keys(currentTokenCache.accessTokens).map(function (key) {\n              return currentTokenCache.accessTokens[key];\n            });\n            if (!currentAccessTokens) return [3 /*break*/, 2];\n            removedAccessTokens_1 = [];\n            currentAccessTokens.forEach(function (tokenEntity) {\n              var tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\n              if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\n                removedAccessTokens_1.push(_this.removeCredential(tokenEntity));\n              }\n            });\n            return [4 /*yield*/, Promise.all(removedAccessTokens_1)];\n          case 1:\n            _a.sent();\n            _a.label = 2;\n          case 2:\n            this.setAccessTokenCredential(credential);\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * retrieve accounts matching all provided filters; if no filter is set, get all accounts\r\n   * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param realm\r\n   */\n  CacheManager.prototype.getAccountsFilteredBy = function (accountFilter) {\n    return this.getAccountsFilteredByInternal(accountFilter ? accountFilter.homeAccountId : Constants.EMPTY_STRING, accountFilter ? accountFilter.environment : Constants.EMPTY_STRING, accountFilter ? accountFilter.realm : Constants.EMPTY_STRING, accountFilter ? accountFilter.nativeAccountId : Constants.EMPTY_STRING);\n  };\n  /**\r\n   * retrieve accounts matching all provided filters; if no filter is set, get all accounts\r\n   * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param realm\r\n   */\n  CacheManager.prototype.getAccountsFilteredByInternal = function (homeAccountId, environment, realm, nativeAccountId) {\n    var _this = this;\n    var allCacheKeys = this.getKeys();\n    var matchingAccounts = {};\n    allCacheKeys.forEach(function (cacheKey) {\n      var entity = _this.getAccount(cacheKey);\n      if (!entity) {\n        return;\n      }\n      if (!!homeAccountId && !_this.matchHomeAccountId(entity, homeAccountId)) {\n        return;\n      }\n      if (!!environment && !_this.matchEnvironment(entity, environment)) {\n        return;\n      }\n      if (!!realm && !_this.matchRealm(entity, realm)) {\n        return;\n      }\n      if (!!nativeAccountId && !_this.matchNativeAccountId(entity, nativeAccountId)) {\n        return;\n      }\n      matchingAccounts[cacheKey] = entity;\n    });\n    return matchingAccounts;\n  };\n  /**\r\n   * retrieve credentails matching all provided filters; if no filter is set, get all credentials\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param credentialType\r\n   * @param clientId\r\n   * @param realm\r\n   * @param target\r\n   */\n  CacheManager.prototype.getCredentialsFilteredBy = function (filter) {\n    return this.getCredentialsFilteredByInternal(filter.homeAccountId, filter.environment, filter.credentialType, filter.clientId, filter.familyId, filter.realm, filter.target, filter.userAssertionHash, filter.tokenType, filter.keyId, filter.requestedClaimsHash);\n  };\n  /**\r\n   * Support function to help match credentials\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param credentialType\r\n   * @param clientId\r\n   * @param realm\r\n   * @param target\r\n   * @param userAssertionHash\r\n   * @param tokenType\r\n   */\n  CacheManager.prototype.getCredentialsFilteredByInternal = function (homeAccountId, environment, credentialType, clientId, familyId, realm, target, userAssertionHash, tokenType, keyId, requestedClaimsHash) {\n    var _this = this;\n    var allCacheKeys = this.getKeys();\n    var matchingCredentials = {\n      idTokens: {},\n      accessTokens: {},\n      refreshTokens: {}\n    };\n    allCacheKeys.forEach(function (cacheKey) {\n      // don't parse any non-credential type cache entities\n      var credType = CredentialEntity.getCredentialType(cacheKey);\n      if (credType === Constants.NOT_DEFINED) {\n        return;\n      }\n      // Attempt retrieval\n      var entity = _this.getSpecificCredential(cacheKey, credType);\n      if (!entity) {\n        return;\n      }\n      if (!!userAssertionHash && !_this.matchUserAssertionHash(entity, userAssertionHash)) {\n        return;\n      }\n      /*\r\n       * homeAccountId can undefined, and we want to filter out cached items that have a homeAccountId of \"\"\r\n       * because we don't want a client_credential request to return a cached token that has a homeAccountId\r\n       */\n      if (typeof homeAccountId === \"string\" && !_this.matchHomeAccountId(entity, homeAccountId)) {\n        return;\n      }\n      if (!!environment && !_this.matchEnvironment(entity, environment)) {\n        return;\n      }\n      if (!!realm && !_this.matchRealm(entity, realm)) {\n        return;\n      }\n      if (!!credentialType && !_this.matchCredentialType(entity, credentialType)) {\n        return;\n      }\n      if (!!clientId && !_this.matchClientId(entity, clientId)) {\n        return;\n      }\n      if (!!familyId && !_this.matchFamilyId(entity, familyId)) {\n        return;\n      }\n      /*\r\n       * idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\r\n       * Resource specific refresh tokens case will be added when the support is deemed necessary\r\n       */\n      if (!!target && !_this.matchTarget(entity, target)) {\n        return;\n      }\n      // If request OR cached entity has requested Claims Hash, check if they match\n      if (requestedClaimsHash || entity.requestedClaimsHash) {\n        // Don't match if either is undefined or they are different\n        if (entity.requestedClaimsHash !== requestedClaimsHash) {\n          return;\n        }\n      }\n      // Access Token with Auth Scheme specific matching\n      if (credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {\n        if (!!tokenType && !_this.matchTokenType(entity, tokenType)) {\n          return;\n        }\n        // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key\n        if (tokenType === AuthenticationScheme.SSH) {\n          if (keyId && !_this.matchKeyId(entity, keyId)) {\n            return;\n          }\n        }\n      }\n      // At this point, the entity matches the request, update cache key if key schema has changed\n      var updatedCacheKey = _this.updateCredentialCacheKey(cacheKey, entity);\n      switch (credType) {\n        case CredentialType.ID_TOKEN:\n          matchingCredentials.idTokens[updatedCacheKey] = entity;\n          break;\n        case CredentialType.ACCESS_TOKEN:\n        case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\n          matchingCredentials.accessTokens[updatedCacheKey] = entity;\n          break;\n        case CredentialType.REFRESH_TOKEN:\n          matchingCredentials.refreshTokens[updatedCacheKey] = entity;\n          break;\n      }\n    });\n    return matchingCredentials;\n  };\n  /**\r\n   * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\r\n   * @param filter\r\n   */\n  CacheManager.prototype.getAppMetadataFilteredBy = function (filter) {\n    return this.getAppMetadataFilteredByInternal(filter.environment, filter.clientId);\n  };\n  /**\r\n   * Support function to help match appMetadata\r\n   * @param environment\r\n   * @param clientId\r\n   */\n  CacheManager.prototype.getAppMetadataFilteredByInternal = function (environment, clientId) {\n    var _this = this;\n    var allCacheKeys = this.getKeys();\n    var matchingAppMetadata = {};\n    allCacheKeys.forEach(function (cacheKey) {\n      // don't parse any non-appMetadata type cache entities\n      if (!_this.isAppMetadata(cacheKey)) {\n        return;\n      }\n      // Attempt retrieval\n      var entity = _this.getAppMetadata(cacheKey);\n      if (!entity) {\n        return;\n      }\n      if (!!environment && !_this.matchEnvironment(entity, environment)) {\n        return;\n      }\n      if (!!clientId && !_this.matchClientId(entity, clientId)) {\n        return;\n      }\n      matchingAppMetadata[cacheKey] = entity;\n    });\n    return matchingAppMetadata;\n  };\n  /**\r\n   * retrieve authorityMetadata that contains a matching alias\r\n   * @param filter\r\n   */\n  CacheManager.prototype.getAuthorityMetadataByAlias = function (host) {\n    var _this = this;\n    var allCacheKeys = this.getAuthorityMetadataKeys();\n    var matchedEntity = null;\n    allCacheKeys.forEach(function (cacheKey) {\n      // don't parse any non-authorityMetadata type cache entities\n      if (!_this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(_this.clientId) === -1) {\n        return;\n      }\n      // Attempt retrieval\n      var entity = _this.getAuthorityMetadata(cacheKey);\n      if (!entity) {\n        return;\n      }\n      if (entity.aliases.indexOf(host) === -1) {\n        return;\n      }\n      matchedEntity = entity;\n    });\n    return matchedEntity;\n  };\n  /**\r\n   * Removes all accounts and related tokens from cache.\r\n   */\n  CacheManager.prototype.removeAllAccounts = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var allCacheKeys, removedAccounts;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            allCacheKeys = this.getKeys();\n            removedAccounts = [];\n            allCacheKeys.forEach(function (cacheKey) {\n              var entity = _this.getAccount(cacheKey);\n              if (!entity) {\n                return;\n              }\n              removedAccounts.push(_this.removeAccount(cacheKey));\n            });\n            return [4 /*yield*/, Promise.all(removedAccounts)];\n          case 1:\n            _a.sent();\n            return [2 /*return*/, true];\n        }\n      });\n    });\n  };\n  /**\r\n   * returns a boolean if the given account is removed\r\n   * @param account\r\n   */\n  CacheManager.prototype.removeAccount = function (accountKey) {\n    return __awaiter(this, void 0, void 0, function () {\n      var account;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            account = this.getAccount(accountKey);\n            if (!account) {\n              throw ClientAuthError.createNoAccountFoundError();\n            }\n            return [4 /*yield*/, this.removeAccountContext(account)];\n          case 1:\n            return [2 /*return*/, _a.sent() && this.removeItem(accountKey, CacheSchemaType.ACCOUNT)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Removes credentials associated with the provided account\r\n   * @param account\r\n   */\n  CacheManager.prototype.removeAccountContext = function (account) {\n    return __awaiter(this, void 0, void 0, function () {\n      var allCacheKeys, accountId, removedCredentials;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            allCacheKeys = this.getKeys();\n            accountId = account.generateAccountId();\n            removedCredentials = [];\n            allCacheKeys.forEach(function (cacheKey) {\n              // don't parse any non-credential type cache entities\n              var credType = CredentialEntity.getCredentialType(cacheKey);\n              if (credType === Constants.NOT_DEFINED) {\n                return;\n              }\n              var cacheEntity = _this.getSpecificCredential(cacheKey, credType);\n              if (!!cacheEntity && accountId === cacheEntity.generateAccountId()) {\n                removedCredentials.push(_this.removeCredential(cacheEntity));\n              }\n            });\n            return [4 /*yield*/, Promise.all(removedCredentials)];\n          case 1:\n            _a.sent();\n            return [2 /*return*/, true];\n        }\n      });\n    });\n  };\n  /**\r\n   * returns a boolean if the given credential is removed\r\n   * @param credential\r\n   */\n  CacheManager.prototype.removeCredential = function (credential) {\n    return __awaiter(this, void 0, void 0, function () {\n      var key, accessTokenWithAuthSchemeEntity, kid;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            key = credential.generateCredentialKey();\n            if (!(credential.credentialType.toLowerCase() === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase())) return [3 /*break*/, 4];\n            if (!(credential.tokenType === AuthenticationScheme.POP)) return [3 /*break*/, 4];\n            accessTokenWithAuthSchemeEntity = credential;\n            kid = accessTokenWithAuthSchemeEntity.keyId;\n            if (!kid) return [3 /*break*/, 4];\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, this.cryptoImpl.removeTokenBindingKey(kid)];\n          case 2:\n            _a.sent();\n            return [3 /*break*/, 4];\n          case 3:\n            _a.sent();\n            throw ClientAuthError.createBindingKeyNotRemovedError();\n          case 4:\n            return [2 /*return*/, this.removeItem(key, CacheSchemaType.CREDENTIAL)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Removes all app metadata objects from cache.\r\n   */\n  CacheManager.prototype.removeAppMetadata = function () {\n    var _this = this;\n    var allCacheKeys = this.getKeys();\n    allCacheKeys.forEach(function (cacheKey) {\n      if (_this.isAppMetadata(cacheKey)) {\n        _this.removeItem(cacheKey, CacheSchemaType.APP_METADATA);\n      }\n    });\n    return true;\n  };\n  /**\r\n   * Retrieve the cached credentials into a cacherecord\r\n   * @param account\r\n   * @param clientId\r\n   * @param scopes\r\n   * @param environment\r\n   * @param authScheme\r\n   */\n  CacheManager.prototype.readCacheRecord = function (account, clientId, request, environment) {\n    var cachedAccount = this.readAccountFromCache(account);\n    var cachedIdToken = this.readIdTokenFromCache(clientId, account);\n    var cachedAccessToken = this.readAccessTokenFromCache(clientId, account, request);\n    var cachedRefreshToken = this.readRefreshTokenFromCache(clientId, account, false);\n    var cachedAppMetadata = this.readAppMetadataFromCache(environment, clientId);\n    if (cachedAccount && cachedIdToken) {\n      cachedAccount.idTokenClaims = new AuthToken(cachedIdToken.secret, this.cryptoImpl).claims;\n    }\n    return {\n      account: cachedAccount,\n      idToken: cachedIdToken,\n      accessToken: cachedAccessToken,\n      refreshToken: cachedRefreshToken,\n      appMetadata: cachedAppMetadata\n    };\n  };\n  /**\r\n   * Retrieve AccountEntity from cache\r\n   * @param account\r\n   */\n  CacheManager.prototype.readAccountFromCache = function (account) {\n    var accountKey = AccountEntity.generateAccountCacheKey(account);\n    return this.getAccount(accountKey);\n  };\n  /**\r\n   * Retrieve AccountEntity from cache\r\n   * @param nativeAccountId\r\n   * @returns AccountEntity or Null\r\n   */\n  CacheManager.prototype.readAccountFromCacheWithNativeAccountId = function (nativeAccountId) {\n    // fetch account from memory\n    var accountFilter = {\n      nativeAccountId: nativeAccountId\n    };\n    var accountCache = this.getAccountsFilteredBy(accountFilter);\n    var accounts = Object.keys(accountCache).map(function (key) {\n      return accountCache[key];\n    });\n    if (accounts.length < 1) {\n      return null;\n    } else if (accounts.length > 1) {\n      throw ClientAuthError.createMultipleMatchingAccountsInCacheError();\n    }\n    return accountCache[0];\n  };\n  /**\r\n   * Retrieve IdTokenEntity from cache\r\n   * @param clientId\r\n   * @param account\r\n   * @param inputRealm\r\n   */\n  CacheManager.prototype.readIdTokenFromCache = function (clientId, account) {\n    var idTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.ID_TOKEN,\n      clientId: clientId,\n      realm: account.tenantId\n    };\n    var credentialCache = this.getCredentialsFilteredBy(idTokenFilter);\n    var idTokens = Object.keys(credentialCache.idTokens).map(function (key) {\n      return credentialCache.idTokens[key];\n    });\n    var numIdTokens = idTokens.length;\n    if (numIdTokens < 1) {\n      return null;\n    } else if (numIdTokens > 1) {\n      throw ClientAuthError.createMultipleMatchingTokensInCacheError();\n    }\n    return idTokens[0];\n  };\n  /**\r\n   * Retrieve AccessTokenEntity from cache\r\n   * @param clientId\r\n   * @param account\r\n   * @param scopes\r\n   * @param authScheme\r\n   */\n  CacheManager.prototype.readAccessTokenFromCache = function (clientId, account, request) {\n    var scopes = new ScopeSet(request.scopes || []);\n    var authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\n    /*\r\n     * Distinguish between Bearer and PoP/SSH token cache types\r\n     * Cast to lowercase to handle \"bearer\" from ADFS\r\n     */\n    var credentialType = authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;\n    var accessTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: credentialType,\n      clientId: clientId,\n      realm: account.tenantId,\n      target: scopes.printScopesLowerCase(),\n      tokenType: authScheme,\n      keyId: request.sshKid,\n      requestedClaimsHash: request.requestedClaimsHash\n    };\n    var credentialCache = this.getCredentialsFilteredBy(accessTokenFilter);\n    var accessTokens = Object.keys(credentialCache.accessTokens).map(function (key) {\n      return credentialCache.accessTokens[key];\n    });\n    var numAccessTokens = accessTokens.length;\n    if (numAccessTokens < 1) {\n      return null;\n    } else if (numAccessTokens > 1) {\n      throw ClientAuthError.createMultipleMatchingTokensInCacheError();\n    }\n    return accessTokens[0];\n  };\n  /**\r\n   * Helper to retrieve the appropriate refresh token from cache\r\n   * @param clientId\r\n   * @param account\r\n   * @param familyRT\r\n   */\n  CacheManager.prototype.readRefreshTokenFromCache = function (clientId, account, familyRT) {\n    var id = familyRT ? THE_FAMILY_ID : undefined;\n    var refreshTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.REFRESH_TOKEN,\n      clientId: clientId,\n      familyId: id\n    };\n    var credentialCache = this.getCredentialsFilteredBy(refreshTokenFilter);\n    var refreshTokens = Object.keys(credentialCache.refreshTokens).map(function (key) {\n      return credentialCache.refreshTokens[key];\n    });\n    var numRefreshTokens = refreshTokens.length;\n    if (numRefreshTokens < 1) {\n      return null;\n    }\n    // address the else case after remove functions address environment aliases\n    return refreshTokens[0];\n  };\n  /**\r\n   * Retrieve AppMetadataEntity from cache\r\n   */\n  CacheManager.prototype.readAppMetadataFromCache = function (environment, clientId) {\n    var appMetadataFilter = {\n      environment: environment,\n      clientId: clientId\n    };\n    var appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);\n    var appMetadataEntries = Object.keys(appMetadata).map(function (key) {\n      return appMetadata[key];\n    });\n    var numAppMetadata = appMetadataEntries.length;\n    if (numAppMetadata < 1) {\n      return null;\n    } else if (numAppMetadata > 1) {\n      throw ClientAuthError.createMultipleMatchingAppMetadataInCacheError();\n    }\n    return appMetadataEntries[0];\n  };\n  /**\r\n   * Return the family_id value associated  with FOCI\r\n   * @param environment\r\n   * @param clientId\r\n   */\n  CacheManager.prototype.isAppMetadataFOCI = function (environment, clientId) {\n    var appMetadata = this.readAppMetadataFromCache(environment, clientId);\n    return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\n  };\n  /**\r\n   * helper to match account ids\r\n   * @param value\r\n   * @param homeAccountId\r\n   */\n  CacheManager.prototype.matchHomeAccountId = function (entity, homeAccountId) {\n    return !!(typeof entity.homeAccountId === \"string\" && homeAccountId === entity.homeAccountId);\n  };\n  /**\r\n   * helper to match assertion\r\n   * @param value\r\n   * @param oboAssertion\r\n   */\n  CacheManager.prototype.matchUserAssertionHash = function (entity, userAssertionHash) {\n    return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);\n  };\n  /**\r\n   * helper to match environment\r\n   * @param value\r\n   * @param environment\r\n   */\n  CacheManager.prototype.matchEnvironment = function (entity, environment) {\n    var cloudMetadata = this.getAuthorityMetadataByAlias(environment);\n    if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {\n      return true;\n    }\n    return false;\n  };\n  /**\r\n   * helper to match credential type\r\n   * @param entity\r\n   * @param credentialType\r\n   */\n  CacheManager.prototype.matchCredentialType = function (entity, credentialType) {\n    return entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase();\n  };\n  /**\r\n   * helper to match client ids\r\n   * @param entity\r\n   * @param clientId\r\n   */\n  CacheManager.prototype.matchClientId = function (entity, clientId) {\n    return !!(entity.clientId && clientId === entity.clientId);\n  };\n  /**\r\n   * helper to match family ids\r\n   * @param entity\r\n   * @param familyId\r\n   */\n  CacheManager.prototype.matchFamilyId = function (entity, familyId) {\n    return !!(entity.familyId && familyId === entity.familyId);\n  };\n  /**\r\n   * helper to match realm\r\n   * @param entity\r\n   * @param realm\r\n   */\n  CacheManager.prototype.matchRealm = function (entity, realm) {\n    return !!(entity.realm && realm === entity.realm);\n  };\n  /**\r\n   * helper to match nativeAccountId\r\n   * @param entity\r\n   * @param nativeAccountId\r\n   * @returns boolean indicating the match result\r\n   */\n  CacheManager.prototype.matchNativeAccountId = function (entity, nativeAccountId) {\n    return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);\n  };\n  /**\r\n   * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\r\n   * @param entity\r\n   * @param target\r\n   */\n  CacheManager.prototype.matchTarget = function (entity, target) {\n    var isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n    if (isNotAccessTokenCredential || !entity.target) {\n      return false;\n    }\n    var entityScopeSet = ScopeSet.fromString(entity.target);\n    var requestTargetScopeSet = ScopeSet.fromString(target);\n    if (!requestTargetScopeSet.containsOnlyOIDCScopes()) {\n      requestTargetScopeSet.removeOIDCScopes(); // ignore OIDC scopes\n    } else {\n      requestTargetScopeSet.removeScope(Constants.OFFLINE_ACCESS_SCOPE);\n    }\n    return entityScopeSet.containsScopeSet(requestTargetScopeSet);\n  };\n  /**\r\n   * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise\r\n   * @param entity\r\n   * @param tokenType\r\n   */\n  CacheManager.prototype.matchTokenType = function (entity, tokenType) {\n    return !!(entity.tokenType && entity.tokenType === tokenType);\n  };\n  /**\r\n   * Returns true if the credential's keyId matches the one in the request, false otherwise\r\n   * @param entity\r\n   * @param tokenType\r\n   */\n  CacheManager.prototype.matchKeyId = function (entity, keyId) {\n    return !!(entity.keyId && entity.keyId === keyId);\n  };\n  /**\r\n   * returns if a given cache entity is of the type appmetadata\r\n   * @param key\r\n   */\n  CacheManager.prototype.isAppMetadata = function (key) {\n    return key.indexOf(APP_METADATA) !== -1;\n  };\n  /**\r\n   * returns if a given cache entity is of the type authoritymetadata\r\n   * @param key\r\n   */\n  CacheManager.prototype.isAuthorityMetadata = function (key) {\n    return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\n  };\n  /**\r\n   * returns cache key used for cloud instance metadata\r\n   */\n  CacheManager.prototype.generateAuthorityMetadataCacheKey = function (authority) {\n    return AUTHORITY_METADATA_CONSTANTS.CACHE_KEY + \"-\" + this.clientId + \"-\" + authority;\n  };\n  /**\r\n   * Returns the specific credential (IdToken/AccessToken/RefreshToken) from the cache\r\n   * @param key\r\n   * @param credType\r\n   */\n  CacheManager.prototype.getSpecificCredential = function (key, credType) {\n    switch (credType) {\n      case CredentialType.ID_TOKEN:\n        {\n          return this.getIdTokenCredential(key);\n        }\n      case CredentialType.ACCESS_TOKEN:\n      case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\n        {\n          return this.getAccessTokenCredential(key);\n        }\n      case CredentialType.REFRESH_TOKEN:\n        {\n          return this.getRefreshTokenCredential(key);\n        }\n      default:\n        return null;\n    }\n  };\n  /**\r\n   * Helper to convert serialized data to object\r\n   * @param obj\r\n   * @param json\r\n   */\n  CacheManager.toObject = function (obj, json) {\n    for (var propertyName in json) {\n      obj[propertyName] = json[propertyName];\n    }\n    return obj;\n  };\n  return CacheManager;\n}();\nvar DefaultStorageClass = /** @class */function (_super) {\n  __extends(DefaultStorageClass, _super);\n  function DefaultStorageClass() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  DefaultStorageClass.prototype.setAccount = function () {\n    var notImplErr = \"Storage interface - setAccount() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getAccount = function () {\n    var notImplErr = \"Storage interface - getAccount() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setIdTokenCredential = function () {\n    var notImplErr = \"Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getIdTokenCredential = function () {\n    var notImplErr = \"Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setAccessTokenCredential = function () {\n    var notImplErr = \"Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getAccessTokenCredential = function () {\n    var notImplErr = \"Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setRefreshTokenCredential = function () {\n    var notImplErr = \"Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getRefreshTokenCredential = function () {\n    var notImplErr = \"Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setAppMetadata = function () {\n    var notImplErr = \"Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getAppMetadata = function () {\n    var notImplErr = \"Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setServerTelemetry = function () {\n    var notImplErr = \"Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getServerTelemetry = function () {\n    var notImplErr = \"Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setAuthorityMetadata = function () {\n    var notImplErr = \"Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getAuthorityMetadata = function () {\n    var notImplErr = \"Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getAuthorityMetadataKeys = function () {\n    var notImplErr = \"Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setThrottlingCache = function () {\n    var notImplErr = \"Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getThrottlingCache = function () {\n    var notImplErr = \"Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.removeItem = function () {\n    var notImplErr = \"Storage interface - removeItem() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.containsKey = function () {\n    var notImplErr = \"Storage interface - containsKey() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getKeys = function () {\n    var notImplErr = \"Storage interface - getKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.clear = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var notImplErr;\n      return __generator(this, function (_a) {\n        notImplErr = \"Storage interface - clear() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n      });\n    });\n  };\n  DefaultStorageClass.prototype.updateCredentialCacheKey = function () {\n    var notImplErr = \"Storage interface - updateCredentialCacheKey() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  return DefaultStorageClass;\n}(CacheManager);\nexport { CacheManager, DefaultStorageClass };","map":{"version":3,"mappings":"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","names":["CacheManager","cryptoImpl","clientId","_this","currentAccounts","getAccountsFilteredBy","accountValues","Object","keys","map","accountKey","numAccounts","length","allAccounts","value","accountEntity","toObject","AccountEntity","accountInfo","getAccountInfo","idToken","readIdTokenFromCache","idTokenClaims","secret","AuthToken","claims","cacheRecord","ClientAuthError","createNullOrUndefinedCacheRecord","account","setAccount","setIdTokenCredential","accessToken","saveAccessToken","_a","refreshToken","setRefreshTokenCredential","appMetadata","setAppMetadata","credential","currentTokenCache","getCredentialsFilteredBy","credentialType","environment","homeAccountId","realm","tokenType","requestedClaimsHash","currentScopes","ScopeSet","fromString","target","currentAccessTokens","accessTokens","key","removedAccessTokens_1","forEach","tokenEntity","tokenScopeSet","intersectingScopeSets","push","removeCredential","Promise","all","setAccessTokenCredential","accountFilter","getAccountsFilteredByInternal","Constants","EMPTY_STRING","nativeAccountId","allCacheKeys","getKeys","matchingAccounts","cacheKey","entity","getAccount","matchHomeAccountId","matchEnvironment","matchRealm","matchNativeAccountId","filter","getCredentialsFilteredByInternal","familyId","userAssertionHash","keyId","matchingCredentials","idTokens","refreshTokens","credType","CredentialEntity","getCredentialType","NOT_DEFINED","getSpecificCredential","matchUserAssertionHash","matchCredentialType","matchClientId","matchFamilyId","matchTarget","CredentialType","ACCESS_TOKEN_WITH_AUTH_SCHEME","matchTokenType","AuthenticationScheme","SSH","matchKeyId","updatedCacheKey","updateCredentialCacheKey","ID_TOKEN","ACCESS_TOKEN","REFRESH_TOKEN","getAppMetadataFilteredByInternal","matchingAppMetadata","isAppMetadata","getAppMetadata","host","getAuthorityMetadataKeys","matchedEntity","isAuthorityMetadata","indexOf","getAuthorityMetadata","aliases","removedAccounts","removeAccount","createNoAccountFoundError","removeAccountContext","removeItem","CacheSchemaType","ACCOUNT","accountId","generateAccountId","removedCredentials","cacheEntity","generateCredentialKey","toLowerCase","POP","accessTokenWithAuthSchemeEntity","kid","removeTokenBindingKey","createBindingKeyNotRemovedError","CREDENTIAL","APP_METADATA","request","cachedAccount","readAccountFromCache","cachedIdToken","cachedAccessToken","readAccessTokenFromCache","cachedRefreshToken","readRefreshTokenFromCache","cachedAppMetadata","readAppMetadataFromCache","generateAccountCacheKey","accountCache","accounts","createMultipleMatchingAccountsInCacheError","idTokenFilter","tenantId","credentialCache","numIdTokens","createMultipleMatchingTokensInCacheError","scopes","authScheme","authenticationScheme","BEARER","accessTokenFilter","printScopesLowerCase","sshKid","numAccessTokens","familyRT","id","THE_FAMILY_ID","undefined","refreshTokenFilter","numRefreshTokens","appMetadataFilter","getAppMetadataFilteredBy","appMetadataEntries","numAppMetadata","createMultipleMatchingAppMetadataInCacheError","cloudMetadata","getAuthorityMetadataByAlias","isNotAccessTokenCredential","entityScopeSet","requestTargetScopeSet","containsOnlyOIDCScopes","removeOIDCScopes","removeScope","OFFLINE_ACCESS_SCOPE","containsScopeSet","AUTHORITY_METADATA_CONSTANTS","CACHE_KEY","authority","getIdTokenCredential","getAccessTokenCredential","getRefreshTokenCredential","obj","json","propertyName","__extends","DefaultStorageClass","notImplErr","AuthError","createUnexpectedError"],"sources":["/home/user/mischangas/node_modules/@azure/msal-common/src/cache/CacheManager.ts"],"sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { AccountCache, AccountFilter, CredentialFilter, CredentialCache, ValidCredentialType, AppMetadataFilter, AppMetadataCache } from \"./utils/CacheTypes\";\r\nimport { CacheRecord } from \"./entities/CacheRecord\";\r\nimport { CacheSchemaType, CredentialType, Constants, APP_METADATA, THE_FAMILY_ID, AUTHORITY_METADATA_CONSTANTS, AuthenticationScheme } from \"../utils/Constants\";\r\nimport { CredentialEntity } from \"./entities/CredentialEntity\";\r\nimport { ScopeSet } from \"../request/ScopeSet\";\r\nimport { AccountEntity } from \"./entities/AccountEntity\";\r\nimport { AccessTokenEntity } from \"./entities/AccessTokenEntity\";\r\nimport { IdTokenEntity } from \"./entities/IdTokenEntity\";\r\nimport { RefreshTokenEntity } from \"./entities/RefreshTokenEntity\";\r\nimport { AuthError } from \"../error/AuthError\";\r\nimport { ICacheManager } from \"./interface/ICacheManager\";\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\nimport { AccountInfo } from \"../account/AccountInfo\";\r\nimport { AppMetadataEntity } from \"./entities/AppMetadataEntity\";\r\nimport { ServerTelemetryEntity } from \"./entities/ServerTelemetryEntity\";\r\nimport { ThrottlingEntity } from \"./entities/ThrottlingEntity\";\r\nimport { AuthToken } from \"../account/AuthToken\";\r\nimport { ICrypto } from \"../crypto/ICrypto\";\r\nimport { AuthorityMetadataEntity } from \"./entities/AuthorityMetadataEntity\";\r\nimport { BaseAuthRequest } from \"../request/BaseAuthRequest\";\r\n\r\n/**\r\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\r\n */\r\nexport abstract class CacheManager implements ICacheManager {\r\n    protected clientId: string;\r\n    protected cryptoImpl: ICrypto;\r\n\r\n    constructor(clientId: string, cryptoImpl: ICrypto) {\r\n        this.clientId = clientId;\r\n        this.cryptoImpl = cryptoImpl;\r\n    }\r\n\r\n    /**\r\n     * fetch the account entity from the platform cache\r\n     *  @param accountKey\r\n     */\r\n    abstract getAccount(accountKey: string): AccountEntity | null;\r\n\r\n    /**\r\n     * set account entity in the platform cache\r\n     * @param account\r\n     */\r\n    abstract setAccount(account: AccountEntity): void;\r\n\r\n    /**\r\n     * fetch the idToken entity from the platform cache\r\n     * @param idTokenKey\r\n     */\r\n    abstract getIdTokenCredential(idTokenKey: string): IdTokenEntity | null;\r\n\r\n    /**\r\n     * set idToken entity to the platform cache\r\n     * @param idToken\r\n     */\r\n    abstract setIdTokenCredential(idToken: IdTokenEntity): void;\r\n\r\n    /**\r\n     * fetch the idToken entity from the platform cache\r\n     * @param accessTokenKey\r\n     */\r\n    abstract getAccessTokenCredential(accessTokenKey: string): AccessTokenEntity | null;\r\n\r\n    /**\r\n     * set idToken entity to the platform cache\r\n     * @param accessToken\r\n     */\r\n    abstract setAccessTokenCredential(accessToken: AccessTokenEntity): void;\r\n\r\n    /**\r\n     * fetch the idToken entity from the platform cache\r\n     * @param refreshTokenKey\r\n     */\r\n    abstract getRefreshTokenCredential(refreshTokenKey: string): RefreshTokenEntity | null;\r\n\r\n    /**\r\n     * set idToken entity to the platform cache\r\n     * @param refreshToken\r\n     */\r\n    abstract setRefreshTokenCredential(refreshToken: RefreshTokenEntity): void;\r\n\r\n    /**\r\n     * fetch appMetadata entity from the platform cache\r\n     * @param appMetadataKey\r\n     */\r\n    abstract getAppMetadata(appMetadataKey: string): AppMetadataEntity | null;\r\n\r\n    /**\r\n     * set appMetadata entity to the platform cache\r\n     * @param appMetadata\r\n     */\r\n    abstract setAppMetadata(appMetadata: AppMetadataEntity): void;\r\n\r\n    /**\r\n     * fetch server telemetry entity from the platform cache\r\n     * @param serverTelemetryKey\r\n     */\r\n    abstract getServerTelemetry(serverTelemetryKey: string): ServerTelemetryEntity | null;\r\n\r\n    /**\r\n     * set server telemetry entity to the platform cache\r\n     * @param serverTelemetryKey\r\n     * @param serverTelemetry\r\n     */\r\n    abstract setServerTelemetry(serverTelemetryKey: string, serverTelemetry: ServerTelemetryEntity): void;\r\n\r\n    /**\r\n     * fetch cloud discovery metadata entity from the platform cache\r\n     * @param key\r\n     */\r\n    abstract getAuthorityMetadata(key: string): AuthorityMetadataEntity | null;\r\n\r\n    /**\r\n     *\r\n     */\r\n    abstract getAuthorityMetadataKeys(): Array<string>;\r\n\r\n    /**\r\n     * set cloud discovery metadata entity to the platform cache\r\n     * @param key\r\n     * @param value\r\n     */\r\n    abstract setAuthorityMetadata(key: string, value: AuthorityMetadataEntity): void;\r\n\r\n    /**\r\n     * fetch throttling entity from the platform cache\r\n     * @param throttlingCacheKey\r\n     */\r\n    abstract getThrottlingCache(throttlingCacheKey: string): ThrottlingEntity | null;\r\n\r\n    /**\r\n     * set throttling entity to the platform cache\r\n     * @param throttlingCacheKey\r\n     * @param throttlingCache\r\n     */\r\n    abstract setThrottlingCache(throttlingCacheKey: string, throttlingCache: ThrottlingEntity): void;;\r\n\r\n    /**\r\n     * Function to remove an item from cache given its key.\r\n     * @param key\r\n     */\r\n    abstract removeItem(key: string, type?: string): boolean;\r\n\r\n    /**\r\n     * Function which returns boolean whether cache contains a specific key.\r\n     * @param key\r\n     */\r\n    abstract containsKey(key: string, type?: string): boolean;\r\n\r\n    /**\r\n     * Function which retrieves all current keys from the cache.\r\n     */\r\n    abstract getKeys(): string[];\r\n\r\n    /**\r\n     * Function which clears cache.\r\n     */\r\n    abstract clear(): Promise<void>;\r\n\r\n    /**\r\n     * Function which updates an outdated credential cache key\r\n     */\r\n    abstract updateCredentialCacheKey(currentCacheKey: string, credential: ValidCredentialType): string;\r\n\r\n    /**\r\n     * Returns all accounts in cache\r\n     */\r\n    getAllAccounts(): AccountInfo[] {\r\n        const currentAccounts: AccountCache = this.getAccountsFilteredBy();\r\n        const accountValues: AccountEntity[] = Object.keys(currentAccounts).map(accountKey => currentAccounts[accountKey]);\r\n        const numAccounts = accountValues.length;\r\n        if (numAccounts < 1) {\r\n            return [];\r\n        } else {\r\n            const allAccounts = accountValues.map<AccountInfo>((value) => {\r\n                const accountEntity = CacheManager.toObject<AccountEntity>(new AccountEntity(), value);\r\n                const accountInfo = accountEntity.getAccountInfo();\r\n                const idToken = this.readIdTokenFromCache(this.clientId, accountInfo);\r\n                if (idToken && !accountInfo.idTokenClaims) {\r\n                    accountInfo.idToken = idToken.secret;\r\n                    accountInfo.idTokenClaims = new AuthToken(idToken.secret, this.cryptoImpl).claims;\r\n                }\r\n\r\n                return accountInfo;\r\n\r\n            });\r\n            return allAccounts;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * saves a cache record\r\n     * @param cacheRecord\r\n     */\r\n    async saveCacheRecord(cacheRecord: CacheRecord): Promise<void> {\r\n        if (!cacheRecord) {\r\n            throw ClientAuthError.createNullOrUndefinedCacheRecord();\r\n        }\r\n\r\n        if (!!cacheRecord.account) {\r\n            this.setAccount(cacheRecord.account);\r\n        }\r\n\r\n        if (!!cacheRecord.idToken) {\r\n            this.setIdTokenCredential(cacheRecord.idToken);\r\n        }\r\n\r\n        if (!!cacheRecord.accessToken) {\r\n            await this.saveAccessToken(cacheRecord.accessToken);\r\n        }\r\n\r\n        if (!!cacheRecord.refreshToken) {\r\n            this.setRefreshTokenCredential(cacheRecord.refreshToken);\r\n        }\r\n\r\n        if (!!cacheRecord.appMetadata) {\r\n            this.setAppMetadata(cacheRecord.appMetadata);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * saves access token credential\r\n     * @param credential\r\n     */\r\n    private async saveAccessToken(credential: AccessTokenEntity): Promise<void> {\r\n        const currentTokenCache = this.getCredentialsFilteredBy({\r\n            clientId: credential.clientId,\r\n            credentialType: credential.credentialType,\r\n            environment: credential.environment,\r\n            homeAccountId: credential.homeAccountId,\r\n            realm: credential.realm,\r\n            tokenType: credential.tokenType,\r\n            requestedClaimsHash: credential.requestedClaimsHash\r\n        });\r\n\r\n        const currentScopes = ScopeSet.fromString(credential.target);\r\n        const currentAccessTokens: AccessTokenEntity[] = Object.keys(currentTokenCache.accessTokens).map(key => currentTokenCache.accessTokens[key]);\r\n\r\n        if (currentAccessTokens) {\r\n            const removedAccessTokens: Array<Promise<boolean>> = [];\r\n            currentAccessTokens.forEach((tokenEntity) => {\r\n                const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\r\n                if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\r\n                    removedAccessTokens.push(this.removeCredential(tokenEntity));\r\n                }\r\n            });\r\n            await Promise.all(removedAccessTokens);\r\n        }\r\n        this.setAccessTokenCredential(credential);\r\n    }\r\n\r\n    /**\r\n     * retrieve accounts matching all provided filters; if no filter is set, get all accounts\r\n     * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n     * @param homeAccountId\r\n     * @param environment\r\n     * @param realm\r\n     */\r\n    getAccountsFilteredBy(accountFilter?: AccountFilter): AccountCache {\r\n        return this.getAccountsFilteredByInternal(\r\n            accountFilter ? accountFilter.homeAccountId : Constants.EMPTY_STRING,\r\n            accountFilter ? accountFilter.environment : Constants.EMPTY_STRING,\r\n            accountFilter ? accountFilter.realm : Constants.EMPTY_STRING,\r\n            accountFilter ? accountFilter.nativeAccountId: Constants.EMPTY_STRING,\r\n        );\r\n    }\r\n\r\n    /**\r\n     * retrieve accounts matching all provided filters; if no filter is set, get all accounts\r\n     * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n     * @param homeAccountId\r\n     * @param environment\r\n     * @param realm\r\n     */\r\n    private getAccountsFilteredByInternal(\r\n        homeAccountId?: string,\r\n        environment?: string,\r\n        realm?: string,\r\n        nativeAccountId?: string,\r\n    ): AccountCache {\r\n        const allCacheKeys = this.getKeys();\r\n        const matchingAccounts: AccountCache = {};\r\n\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            const entity: AccountEntity | null = this.getAccount(cacheKey);\r\n\r\n            if (!entity) {\r\n                return;\r\n            }\r\n\r\n            if (!!homeAccountId && !this.matchHomeAccountId(entity, homeAccountId)) {\r\n                return;\r\n            }\r\n\r\n            if (!!environment && !this.matchEnvironment(entity, environment)) {\r\n                return;\r\n            }\r\n\r\n            if (!!realm && !this.matchRealm(entity, realm)) {\r\n                return;\r\n            }\r\n\r\n            if (!!nativeAccountId && !this.matchNativeAccountId(entity, nativeAccountId)) {\r\n                return;\r\n            }\r\n\r\n            matchingAccounts[cacheKey] = entity;\r\n        });\r\n\r\n        return matchingAccounts;\r\n    }\r\n\r\n    /**\r\n     * retrieve credentails matching all provided filters; if no filter is set, get all credentials\r\n     * @param homeAccountId\r\n     * @param environment\r\n     * @param credentialType\r\n     * @param clientId\r\n     * @param realm\r\n     * @param target\r\n     */\r\n    getCredentialsFilteredBy(filter: CredentialFilter): CredentialCache {\r\n        return this.getCredentialsFilteredByInternal(\r\n            filter.homeAccountId,\r\n            filter.environment,\r\n            filter.credentialType,\r\n            filter.clientId,\r\n            filter.familyId,\r\n            filter.realm,\r\n            filter.target,\r\n            filter.userAssertionHash,\r\n            filter.tokenType,\r\n            filter.keyId,\r\n            filter.requestedClaimsHash\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Support function to help match credentials\r\n     * @param homeAccountId\r\n     * @param environment\r\n     * @param credentialType\r\n     * @param clientId\r\n     * @param realm\r\n     * @param target\r\n     * @param userAssertionHash\r\n     * @param tokenType\r\n     */\r\n    private getCredentialsFilteredByInternal(\r\n        homeAccountId?: string,\r\n        environment?: string,\r\n        credentialType?: string,\r\n        clientId?: string,\r\n        familyId?: string,\r\n        realm?: string,\r\n        target?: string,\r\n        userAssertionHash?: string,\r\n        tokenType?: AuthenticationScheme,\r\n        keyId?: string,\r\n        requestedClaimsHash?: string\r\n    ): CredentialCache {\r\n        const allCacheKeys = this.getKeys();\r\n        const matchingCredentials: CredentialCache = {\r\n            idTokens: {},\r\n            accessTokens: {},\r\n            refreshTokens: {},\r\n        };\r\n\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            // don't parse any non-credential type cache entities\r\n            const credType = CredentialEntity.getCredentialType(cacheKey);\r\n\r\n            if (credType === Constants.NOT_DEFINED) {\r\n                return;\r\n            }\r\n\r\n            // Attempt retrieval\r\n            const entity = this.getSpecificCredential(cacheKey, credType);\r\n\r\n            if (!entity) {\r\n                return;\r\n            }\r\n\r\n            if (!!userAssertionHash && !this.matchUserAssertionHash(entity, userAssertionHash)) {\r\n                return;\r\n            }\r\n\r\n            /*\r\n             * homeAccountId can undefined, and we want to filter out cached items that have a homeAccountId of \"\"\r\n             * because we don't want a client_credential request to return a cached token that has a homeAccountId\r\n             */\r\n            if ((typeof homeAccountId === \"string\") && !this.matchHomeAccountId(entity, homeAccountId)) {\r\n                return;\r\n            }\r\n\r\n            if (!!environment && !this.matchEnvironment(entity, environment)) {\r\n                return;\r\n            }\r\n\r\n            if (!!realm && !this.matchRealm(entity, realm)) {\r\n                return;\r\n            }\r\n\r\n            if (!!credentialType && !this.matchCredentialType(entity, credentialType)) {\r\n                return;\r\n            }\r\n\r\n            if (!!clientId && !this.matchClientId(entity, clientId)) {\r\n                return;\r\n            }\r\n\r\n            if (!!familyId && !this.matchFamilyId(entity, familyId)) {\r\n                return;\r\n            }\r\n\r\n            /*\r\n             * idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\r\n             * Resource specific refresh tokens case will be added when the support is deemed necessary\r\n             */\r\n            if (!!target && !this.matchTarget(entity, target)) {\r\n                return;\r\n            }\r\n\r\n            // If request OR cached entity has requested Claims Hash, check if they match\r\n            if (requestedClaimsHash || entity.requestedClaimsHash) {\r\n                // Don't match if either is undefined or they are different\r\n                if (entity.requestedClaimsHash !== requestedClaimsHash) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            // Access Token with Auth Scheme specific matching\r\n            if (credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {\r\n                if(!!tokenType && !this.matchTokenType(entity, tokenType)) {\r\n                    return;\r\n                }\r\n\r\n                // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key\r\n                if (tokenType === AuthenticationScheme.SSH) {\r\n                    if(keyId && !this.matchKeyId(entity, keyId)) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // At this point, the entity matches the request, update cache key if key schema has changed\r\n            const updatedCacheKey = this.updateCredentialCacheKey(cacheKey, entity);\r\n\r\n            switch (credType) {\r\n                case CredentialType.ID_TOKEN:\r\n                    matchingCredentials.idTokens[updatedCacheKey] = entity as IdTokenEntity;\r\n                    break;\r\n                case CredentialType.ACCESS_TOKEN:\r\n                case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\r\n                    matchingCredentials.accessTokens[updatedCacheKey] = entity as AccessTokenEntity;\r\n                    break;\r\n                case CredentialType.REFRESH_TOKEN:\r\n                    matchingCredentials.refreshTokens[updatedCacheKey] = entity as RefreshTokenEntity;\r\n                    break;\r\n            }\r\n        });\r\n\r\n        return matchingCredentials;\r\n    }\r\n\r\n    /**\r\n     * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\r\n     * @param filter\r\n     */\r\n    getAppMetadataFilteredBy(filter: AppMetadataFilter): AppMetadataCache {\r\n        return this.getAppMetadataFilteredByInternal(\r\n            filter.environment,\r\n            filter.clientId,\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Support function to help match appMetadata\r\n     * @param environment\r\n     * @param clientId\r\n     */\r\n    private getAppMetadataFilteredByInternal(\r\n        environment?: string,\r\n        clientId?: string\r\n    ): AppMetadataCache {\r\n\r\n        const allCacheKeys = this.getKeys();\r\n        const matchingAppMetadata: AppMetadataCache = {};\r\n\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            // don't parse any non-appMetadata type cache entities\r\n            if (!this.isAppMetadata(cacheKey)) {\r\n                return;\r\n            }\r\n\r\n            // Attempt retrieval\r\n            const entity = this.getAppMetadata(cacheKey);\r\n\r\n            if (!entity) {\r\n                return;\r\n            }\r\n\r\n            if (!!environment && !this.matchEnvironment(entity, environment)) {\r\n                return;\r\n            }\r\n\r\n            if (!!clientId && !this.matchClientId(entity, clientId)) {\r\n                return;\r\n            }\r\n\r\n            matchingAppMetadata[cacheKey] = entity;\r\n\r\n        });\r\n\r\n        return matchingAppMetadata;\r\n    }\r\n\r\n    /**\r\n     * retrieve authorityMetadata that contains a matching alias\r\n     * @param filter\r\n     */\r\n    getAuthorityMetadataByAlias(host: string): AuthorityMetadataEntity | null {\r\n        const allCacheKeys = this.getAuthorityMetadataKeys();\r\n        let matchedEntity = null;\r\n\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            // don't parse any non-authorityMetadata type cache entities\r\n            if (!this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(this.clientId) === -1) {\r\n                return;\r\n            }\r\n\r\n            // Attempt retrieval\r\n            const entity = this.getAuthorityMetadata(cacheKey);\r\n\r\n            if (!entity) {\r\n                return;\r\n            }\r\n\r\n            if (entity.aliases.indexOf(host) === -1) {\r\n                return;\r\n            }\r\n\r\n            matchedEntity = entity;\r\n\r\n        });\r\n\r\n        return matchedEntity;\r\n    }\r\n\r\n    /**\r\n     * Removes all accounts and related tokens from cache.\r\n     */\r\n    async removeAllAccounts(): Promise<boolean> {\r\n        const allCacheKeys = this.getKeys();\r\n        const removedAccounts: Array<Promise<boolean>> = [];\r\n\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            const entity = this.getAccount(cacheKey);\r\n            if (!entity) {\r\n                return;\r\n            }\r\n            removedAccounts.push(this.removeAccount(cacheKey));\r\n        });\r\n\r\n        await Promise.all(removedAccounts);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * returns a boolean if the given account is removed\r\n     * @param account\r\n     */\r\n    async removeAccount(accountKey: string): Promise<boolean> {\r\n        const account = this.getAccount(accountKey);\r\n        if (!account) {\r\n            throw ClientAuthError.createNoAccountFoundError();\r\n        }\r\n        return (await this.removeAccountContext(account) && this.removeItem(accountKey, CacheSchemaType.ACCOUNT));\r\n    }\r\n\r\n    /**\r\n     * Removes credentials associated with the provided account\r\n     * @param account\r\n     */\r\n    async removeAccountContext(account: AccountEntity): Promise<boolean> {\r\n        const allCacheKeys = this.getKeys();\r\n        const accountId = account.generateAccountId();\r\n        const removedCredentials: Array<Promise<boolean>> = [];\r\n\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            // don't parse any non-credential type cache entities\r\n            const credType = CredentialEntity.getCredentialType(cacheKey);\r\n            if (credType === Constants.NOT_DEFINED) {\r\n                return;\r\n            }\r\n\r\n            const cacheEntity = this.getSpecificCredential(cacheKey, credType);\r\n            if (!!cacheEntity && accountId === cacheEntity.generateAccountId()) {\r\n                removedCredentials.push(this.removeCredential(cacheEntity));\r\n            }\r\n        });\r\n\r\n        await Promise.all(removedCredentials);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * returns a boolean if the given credential is removed\r\n     * @param credential\r\n     */\r\n    async removeCredential(credential: CredentialEntity): Promise<boolean> {\r\n        const key = credential.generateCredentialKey();\r\n\r\n        // Remove Token Binding Key from key store for PoP Tokens Credentials\r\n        if (credential.credentialType.toLowerCase() === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) {\r\n            if(credential.tokenType === AuthenticationScheme.POP) {\r\n                const accessTokenWithAuthSchemeEntity = credential as AccessTokenEntity;\r\n                const kid = accessTokenWithAuthSchemeEntity.keyId;\r\n\r\n                if (kid) {\r\n                    try {\r\n                        await this.cryptoImpl.removeTokenBindingKey(kid);\r\n                    } catch (error) {\r\n                        throw ClientAuthError.createBindingKeyNotRemovedError();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return this.removeItem(key, CacheSchemaType.CREDENTIAL);\r\n    }\r\n\r\n    /**\r\n     * Removes all app metadata objects from cache.\r\n     */\r\n    removeAppMetadata(): boolean {\r\n        const allCacheKeys = this.getKeys();\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            if (this.isAppMetadata(cacheKey)) {\r\n                this.removeItem(cacheKey, CacheSchemaType.APP_METADATA);\r\n            }\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Retrieve the cached credentials into a cacherecord\r\n     * @param account\r\n     * @param clientId\r\n     * @param scopes\r\n     * @param environment\r\n     * @param authScheme\r\n     */\r\n    readCacheRecord(account: AccountInfo, clientId: string, request: BaseAuthRequest, environment: string): CacheRecord {\r\n\r\n        const cachedAccount = this.readAccountFromCache(account);\r\n        const cachedIdToken = this.readIdTokenFromCache(clientId, account);\r\n        const cachedAccessToken = this.readAccessTokenFromCache(clientId, account, request);\r\n        const cachedRefreshToken = this.readRefreshTokenFromCache(clientId, account, false);\r\n        const cachedAppMetadata = this.readAppMetadataFromCache(environment, clientId);\r\n\r\n        if (cachedAccount && cachedIdToken) {\r\n            cachedAccount.idTokenClaims = new AuthToken(cachedIdToken.secret, this.cryptoImpl).claims;\r\n        }\r\n\r\n        return {\r\n            account: cachedAccount,\r\n            idToken: cachedIdToken,\r\n            accessToken: cachedAccessToken,\r\n            refreshToken: cachedRefreshToken,\r\n            appMetadata: cachedAppMetadata,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Retrieve AccountEntity from cache\r\n     * @param account\r\n     */\r\n    readAccountFromCache(account: AccountInfo): AccountEntity | null {\r\n        const accountKey: string = AccountEntity.generateAccountCacheKey(account);\r\n        return this.getAccount(accountKey);\r\n    }\r\n\r\n    /**\r\n     * Retrieve AccountEntity from cache\r\n     * @param nativeAccountId\r\n     * @returns AccountEntity or Null\r\n     */\r\n    readAccountFromCacheWithNativeAccountId(nativeAccountId: string): AccountEntity | null {\r\n        // fetch account from memory\r\n        const accountFilter: AccountFilter = {\r\n            nativeAccountId\r\n        };\r\n        const accountCache: AccountCache = this.getAccountsFilteredBy(accountFilter);\r\n        const accounts = Object.keys(accountCache).map((key) => accountCache[key]);\r\n\r\n        if (accounts.length < 1) {\r\n            return null;\r\n        } else if (accounts.length > 1) {\r\n            throw ClientAuthError.createMultipleMatchingAccountsInCacheError();\r\n        }\r\n\r\n        return accountCache[0];\r\n    }\r\n\r\n    /**\r\n     * Retrieve IdTokenEntity from cache\r\n     * @param clientId\r\n     * @param account\r\n     * @param inputRealm\r\n     */\r\n    readIdTokenFromCache(clientId: string, account: AccountInfo): IdTokenEntity | null {\r\n        const idTokenFilter: CredentialFilter = {\r\n            homeAccountId: account.homeAccountId,\r\n            environment: account.environment,\r\n            credentialType: CredentialType.ID_TOKEN,\r\n            clientId: clientId,\r\n            realm: account.tenantId,\r\n        };\r\n\r\n        const credentialCache: CredentialCache = this.getCredentialsFilteredBy(idTokenFilter);\r\n        const idTokens = Object.keys(credentialCache.idTokens).map((key) => credentialCache.idTokens[key]);\r\n        const numIdTokens = idTokens.length;\r\n\r\n        if (numIdTokens < 1) {\r\n            return null;\r\n        } else if (numIdTokens > 1) {\r\n            throw ClientAuthError.createMultipleMatchingTokensInCacheError();\r\n        }\r\n\r\n        return idTokens[0] as IdTokenEntity;\r\n    }\r\n\r\n    /**\r\n     * Retrieve AccessTokenEntity from cache\r\n     * @param clientId\r\n     * @param account\r\n     * @param scopes\r\n     * @param authScheme\r\n     */\r\n    readAccessTokenFromCache(clientId: string, account: AccountInfo, request: BaseAuthRequest): AccessTokenEntity | null {\r\n        const scopes =  new ScopeSet(request.scopes || []);\r\n        const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\r\n        /*\r\n         * Distinguish between Bearer and PoP/SSH token cache types\r\n         * Cast to lowercase to handle \"bearer\" from ADFS\r\n         */\r\n        const credentialType = (authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase()) ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;\r\n\r\n        const accessTokenFilter: CredentialFilter = {\r\n            homeAccountId: account.homeAccountId,\r\n            environment: account.environment,\r\n            credentialType: credentialType,\r\n            clientId,\r\n            realm: account.tenantId,\r\n            target: scopes.printScopesLowerCase(),\r\n            tokenType: authScheme,\r\n            keyId: request.sshKid,\r\n            requestedClaimsHash: request.requestedClaimsHash,\r\n        };\r\n\r\n        const credentialCache: CredentialCache = this.getCredentialsFilteredBy(accessTokenFilter);\r\n\r\n        const accessTokens = Object.keys(credentialCache.accessTokens).map((key) => credentialCache.accessTokens[key]);\r\n\r\n        const numAccessTokens = accessTokens.length;\r\n        if (numAccessTokens < 1) {\r\n            return null;\r\n        } else if (numAccessTokens > 1) {\r\n            throw ClientAuthError.createMultipleMatchingTokensInCacheError();\r\n        }\r\n\r\n        return accessTokens[0] as AccessTokenEntity;\r\n    }\r\n\r\n    /**\r\n     * Helper to retrieve the appropriate refresh token from cache\r\n     * @param clientId\r\n     * @param account\r\n     * @param familyRT\r\n     */\r\n    readRefreshTokenFromCache(clientId: string, account: AccountInfo, familyRT: boolean): RefreshTokenEntity | null {\r\n        const id = familyRT ? THE_FAMILY_ID : undefined;\r\n        const refreshTokenFilter: CredentialFilter = {\r\n            homeAccountId: account.homeAccountId,\r\n            environment: account.environment,\r\n            credentialType: CredentialType.REFRESH_TOKEN,\r\n            clientId: clientId,\r\n            familyId: id,\r\n        };\r\n\r\n        const credentialCache: CredentialCache = this.getCredentialsFilteredBy(refreshTokenFilter);\r\n        const refreshTokens = Object.keys(credentialCache.refreshTokens).map((key) => credentialCache.refreshTokens[key]);\r\n\r\n        const numRefreshTokens = refreshTokens.length;\r\n        if (numRefreshTokens < 1) {\r\n            return null;\r\n        }\r\n        // address the else case after remove functions address environment aliases\r\n\r\n        return refreshTokens[0] as RefreshTokenEntity;\r\n    }\r\n\r\n    /**\r\n     * Retrieve AppMetadataEntity from cache\r\n     */\r\n    readAppMetadataFromCache(environment: string, clientId: string): AppMetadataEntity | null {\r\n        const appMetadataFilter: AppMetadataFilter = {\r\n            environment,\r\n            clientId,\r\n        };\r\n\r\n        const appMetadata: AppMetadataCache = this.getAppMetadataFilteredBy(appMetadataFilter);\r\n        const appMetadataEntries: AppMetadataEntity[] = Object.keys(appMetadata).map((key) => appMetadata[key]);\r\n\r\n        const numAppMetadata = appMetadataEntries.length;\r\n        if (numAppMetadata < 1) {\r\n            return null;\r\n        } else if (numAppMetadata > 1) {\r\n            throw ClientAuthError.createMultipleMatchingAppMetadataInCacheError();\r\n        }\r\n\r\n        return appMetadataEntries[0] as AppMetadataEntity;\r\n    }\r\n\r\n    /**\r\n     * Return the family_id value associated  with FOCI\r\n     * @param environment\r\n     * @param clientId\r\n     */\r\n    isAppMetadataFOCI(environment: string, clientId: string): boolean {\r\n        const appMetadata = this.readAppMetadataFromCache(environment, clientId);\r\n        return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\r\n    }\r\n\r\n    /**\r\n     * helper to match account ids\r\n     * @param value\r\n     * @param homeAccountId\r\n     */\r\n    private matchHomeAccountId(entity: AccountEntity | CredentialEntity, homeAccountId: string): boolean {\r\n        return !!((typeof entity.homeAccountId === \"string\") && (homeAccountId === entity.homeAccountId));\r\n    }\r\n\r\n    /**\r\n     * helper to match assertion\r\n     * @param value\r\n     * @param oboAssertion\r\n     */\r\n    private matchUserAssertionHash(entity: CredentialEntity, userAssertionHash: string): boolean {\r\n        return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);\r\n    }\r\n\r\n    /**\r\n     * helper to match environment\r\n     * @param value\r\n     * @param environment\r\n     */\r\n    private matchEnvironment(entity: AccountEntity | CredentialEntity | AppMetadataEntity, environment: string): boolean {\r\n        const cloudMetadata = this.getAuthorityMetadataByAlias(environment);\r\n        if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * helper to match credential type\r\n     * @param entity\r\n     * @param credentialType\r\n     */\r\n    private matchCredentialType(entity: CredentialEntity, credentialType: string): boolean {\r\n        return (entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase());\r\n    }\r\n\r\n    /**\r\n     * helper to match client ids\r\n     * @param entity\r\n     * @param clientId\r\n     */\r\n    private matchClientId(entity: CredentialEntity | AppMetadataEntity, clientId: string): boolean {\r\n        return !!(entity.clientId && clientId === entity.clientId);\r\n    }\r\n\r\n    /**\r\n     * helper to match family ids\r\n     * @param entity\r\n     * @param familyId\r\n     */\r\n    private matchFamilyId(entity: CredentialEntity | AppMetadataEntity, familyId: string): boolean {\r\n        return !!(entity.familyId && familyId === entity.familyId);\r\n    }\r\n\r\n    /**\r\n     * helper to match realm\r\n     * @param entity\r\n     * @param realm\r\n     */\r\n    private matchRealm(entity: AccountEntity | CredentialEntity, realm: string): boolean {\r\n        return !!(entity.realm && realm === entity.realm);\r\n    }\r\n\r\n    /**\r\n     * helper to match nativeAccountId\r\n     * @param entity\r\n     * @param nativeAccountId\r\n     * @returns boolean indicating the match result\r\n     */\r\n    private matchNativeAccountId(entity: AccountEntity, nativeAccountId: string): boolean {\r\n        return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\r\n     * @param entity\r\n     * @param target\r\n     */\r\n    private matchTarget(entity: CredentialEntity, target: string): boolean {\r\n        const isNotAccessTokenCredential = (entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);\r\n\r\n        if ( isNotAccessTokenCredential || !entity.target) {\r\n            return false;\r\n        }\r\n\r\n        const entityScopeSet: ScopeSet = ScopeSet.fromString(entity.target);\r\n        const requestTargetScopeSet: ScopeSet = ScopeSet.fromString(target);\r\n\r\n        if (!requestTargetScopeSet.containsOnlyOIDCScopes()) {\r\n            requestTargetScopeSet.removeOIDCScopes(); // ignore OIDC scopes\r\n        } else {\r\n            requestTargetScopeSet.removeScope(Constants.OFFLINE_ACCESS_SCOPE);\r\n        }\r\n        return entityScopeSet.containsScopeSet(requestTargetScopeSet);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise\r\n     * @param entity\r\n     * @param tokenType\r\n     */\r\n    private matchTokenType(entity: CredentialEntity, tokenType: AuthenticationScheme): boolean {\r\n        return !!(entity.tokenType && entity.tokenType === tokenType);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the credential's keyId matches the one in the request, false otherwise\r\n     * @param entity\r\n     * @param tokenType\r\n     */\r\n    private matchKeyId(entity: CredentialEntity, keyId: string): boolean {\r\n        return !!(entity.keyId && entity.keyId === keyId);\r\n    }\r\n\r\n    /**\r\n     * returns if a given cache entity is of the type appmetadata\r\n     * @param key\r\n     */\r\n    private isAppMetadata(key: string): boolean {\r\n        return key.indexOf(APP_METADATA) !== -1;\r\n    }\r\n\r\n    /**\r\n     * returns if a given cache entity is of the type authoritymetadata\r\n     * @param key\r\n     */\r\n    protected isAuthorityMetadata(key: string): boolean {\r\n        return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\r\n    }\r\n\r\n    /**\r\n     * returns cache key used for cloud instance metadata\r\n     */\r\n    generateAuthorityMetadataCacheKey(authority: string): string {\r\n        return `${AUTHORITY_METADATA_CONSTANTS.CACHE_KEY}-${this.clientId}-${authority}`;\r\n    }\r\n\r\n    /**\r\n     * Returns the specific credential (IdToken/AccessToken/RefreshToken) from the cache\r\n     * @param key\r\n     * @param credType\r\n     */\r\n    private getSpecificCredential(key: string, credType: string): ValidCredentialType | null {\r\n        switch (credType) {\r\n            case CredentialType.ID_TOKEN: {\r\n                return this.getIdTokenCredential(key);\r\n            }\r\n            case CredentialType.ACCESS_TOKEN:\r\n            case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME: {\r\n                return this.getAccessTokenCredential(key);\r\n            }\r\n            case CredentialType.REFRESH_TOKEN: {\r\n                return this.getRefreshTokenCredential(key);\r\n            }\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper to convert serialized data to object\r\n     * @param obj\r\n     * @param json\r\n     */\r\n    static toObject<T>(obj: T, json: object): T {\r\n        for (const propertyName in json) {\r\n            obj[propertyName] = json[propertyName];\r\n        }\r\n        return obj;\r\n    }\r\n}\r\n\r\nexport class DefaultStorageClass extends CacheManager {\r\n    setAccount(): void {\r\n        const notImplErr = \"Storage interface - setAccount() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getAccount(): AccountEntity {\r\n        const notImplErr = \"Storage interface - getAccount() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setIdTokenCredential(): void {\r\n        const notImplErr = \"Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getIdTokenCredential(): IdTokenEntity {\r\n        const notImplErr = \"Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setAccessTokenCredential(): void {\r\n        const notImplErr = \"Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getAccessTokenCredential(): AccessTokenEntity {\r\n        const notImplErr = \"Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setRefreshTokenCredential(): void {\r\n        const notImplErr = \"Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getRefreshTokenCredential(): RefreshTokenEntity {\r\n        const notImplErr = \"Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setAppMetadata(): void {\r\n        const notImplErr = \"Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getAppMetadata(): AppMetadataEntity {\r\n        const notImplErr = \"Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setServerTelemetry(): void {\r\n        const notImplErr = \"Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getServerTelemetry(): ServerTelemetryEntity {\r\n        const notImplErr = \"Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setAuthorityMetadata(): void {\r\n        const notImplErr = \"Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getAuthorityMetadata(): AuthorityMetadataEntity | null {\r\n        const notImplErr = \"Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getAuthorityMetadataKeys(): Array<string> {\r\n        const notImplErr = \"Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setThrottlingCache(): void {\r\n        const notImplErr = \"Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getThrottlingCache(): ThrottlingEntity {\r\n        const notImplErr = \"Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    removeItem(): boolean {\r\n        const notImplErr = \"Storage interface - removeItem() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    containsKey(): boolean {\r\n        const notImplErr = \"Storage interface - containsKey() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getKeys(): string[] {\r\n        const notImplErr = \"Storage interface - getKeys() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    async clear(): Promise<void> {\r\n        const notImplErr = \"Storage interface - clear() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    updateCredentialCacheKey(): string {\r\n        const notImplErr = \"Storage interface - updateCredentialCacheKey() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}